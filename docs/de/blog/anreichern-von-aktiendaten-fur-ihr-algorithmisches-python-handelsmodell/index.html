<!doctype html><html><head><title>Anreichern von Aktiendaten für Ihr algorithmisches Python-Handelsmodell</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="index, follow"><meta name=description content="Der typische maschinelle Lernalgorithmus kann nur mit den Daten arbeiten, die er erhalten hat. Er kann (in der Regel) keine neuen Merkmale oder Interpretationen wie &#34;Wenn das Volumen steigt und die 3. Ableitung des Preises steigt, wird der Preis höchstwahrscheinlich steigen&#34; erstellen, sondern kann stattdessen nur auf die Daten &#34;schauen&#34;, die er erhalten hat. Das wären Berechnungen wie &#34;wenn der Preis über 100 USD liegt und das Volumen über 2000, wird der Preis höchstwahrscheinlich steigen&#34;.  "><link rel=canonical href=https://datafortress.cloud/de/blog/anreichern-von-aktiendaten-fur-ihr-algorithmisches-python-handelsmodell/><link rel=alternate href=https://datafortress.cloud/de/blog/anreichern-von-aktiendaten-fur-ihr-algorithmisches-python-handelsmodell/ hreflang=de-de><link rel=icon type=image/png href=https://datafortress.cloud/images/logo.webp><meta property="og:title" content="Anreichern von Aktiendaten für Ihr algorithmisches Python-Handelsmodell"><meta property="og:description" content="Der typische maschinelle Lernalgorithmus kann nur mit den Daten arbeiten, die er erhalten hat. Er kann (in der Regel) keine neuen Merkmale oder Interpretationen wie &#34;Wenn das Volumen steigt und die 3. Ableitung des Preises steigt, wird der Preis höchstwahrscheinlich steigen&#34; erstellen, sondern kann stattdessen nur auf die Daten &#34;schauen&#34;, die er erhalten hat. Das wären Berechnungen wie &#34;wenn der Preis über 100 USD liegt und das Volumen über 2000, wird der Preis höchstwahrscheinlich steigen&#34;.  "><meta property="og:type" content="article"><meta property="og:url" content="https://datafortress.cloud/de/blog/anreichern-von-aktiendaten-fur-ihr-algorithmisches-python-handelsmodell/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-01-26T23:00:00+00:00"><meta property="article:modified_time" content="2022-07-07T21:15:36+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Anreichern von Aktiendaten für Ihr algorithmisches Python-Handelsmodell"><meta name=twitter:description content="Der typische maschinelle Lernalgorithmus kann nur mit den Daten arbeiten, die er erhalten hat. Er kann (in der Regel) keine neuen Merkmale oder Interpretationen wie &#34;Wenn das Volumen steigt und die 3. Ableitung des Preises steigt, wird der Preis höchstwahrscheinlich steigen&#34; erstellen, sondern kann stattdessen nur auf die Daten &#34;schauen&#34;, die er erhalten hat. Das wären Berechnungen wie &#34;wenn der Preis über 100 USD liegt und das Volumen über 2000, wird der Preis höchstwahrscheinlich steigen&#34;.  "><script type=application/ld+json>{"@context":"https://schema.org/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/datafortress.cloud\/de\/blog\/anreichern-von-aktiendaten-fur-ihr-algorithmisches-python-handelsmodell\/"},"headline":"Anreichern von Aktiendaten für Ihr algorithmisches Python-Handelsmodell","description":"Der typische maschinelle Lernalgorithmus kann nur mit den Daten arbeiten, die er erhalten hat. Er kann (in der Regel) keine neuen Merkmale oder Interpretationen wie \u0022Wenn das Volumen steigt und die 3. Ableitung des Preises steigt, wird der Preis höchstwahrscheinlich steigen\u0022 erstellen, sondern kann stattdessen nur auf die Daten \u0022schauen\u0022, die er erhalten hat. Das wären Berechnungen wie \u0022wenn der Preis über 100 USD liegt und das Volumen über 2000, wird der Preis höchstwahrscheinlich steigen\u0022.  ","image":[],"datePublished":"2022-01-26T23:00:00\u002b00:00","dateModified":"2022-07-07T21:15:36\u002b02:00","author":{"@type":"Person","name":"Justin Guese"},"publisher":{"@type":"Organization","name":"Datafortress.cloud","logo":{"@type":"ImageObject","url":"https:\/\/datafortress.cloud\/images\/logo.webp"}}}</script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.4/css/bulma.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.13.1/css/all.css integrity=sha384-xxzQGERXS00kBmZW/6qxqJPyxW3UR0BPsL4c8ILaIWXva5kFi7TxkIIaMiKtqV1Q crossorigin=anonymous><link rel=stylesheet href=https://datafortress.cloud//css/style.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js></script></head><body><header><nav class=navbar><div class=navbar-brand><a class=navbar-item href=https://datafortress.cloud/ title=Datafortress.cloud><img src=https://datafortress.cloud/images/logo.webp alt="VR, Big-Data and Cloud for your Business."></a>
<a href=https://datafortress.cloud/ title="VR, Big-Data and Cloud for your Business." class=navbar-item><span class=is-size-4>Datafortress.cloud</span></a>
<a href=https://datafortress.cloud/contact class=navbar-item title="RSS feed"><span class="icon fa-lg has-text-dark"><i class="fa fa-envelope"></i></span></a>
<a href=https://datafortress.cloud/index.xml class=navbar-item title="RSS feed"><span class="icon fa-lg has-text-dark"><i class="fa fa-rss"></i></span></a>
<a role=button class=navbar-burger aria-label=menu aria-expanded=false><span aria-hidden=true></span>
<span aria-hidden=true></span>
<span aria-hidden=true></span></a></div><div class="navbar-menu navbar-end"><a href=https://datafortress.cloud/products class=navbar-item>Products</a>
<a href=https://datafortress.cloud/services class=navbar-item>Services</a>
<a href=https://datafortress.cloud/project class=navbar-item>Portfolio</a>
<a href=https://datafortress.cloud/blog class=navbar-item>Blog</a>
<a href=https://datafortress.cloud/contact class=navbar-item>Contact</a>
<a href=https://datafortress.cloud/ class=navbar-item>about</a></div></nav><script>$(document).ready(function(){$(".navbar-burger").click(function(){$(".navbar-burger").toggleClass("is-active"),$(".navbar-menu").toggleClass("is-active")})})</script></header><main><article><div class="columns is-centered"><div class="column max-800px"><section class=section><h1 class="title is-2">Anreichern von Aktiendaten für Ihr algorithmisches Python-Handelsmodell</h1><div class="columns is-tablet"><div class="columns is-mobile"><div class="column is-narrow"><figure class="image is-64x64"><img class=is-rounded src=https://datafortress.cloud/images/logo.webp alt="Justin Guese" title="Justin Guese"></figure></div><div class=column><p>Justin Guese |
<time datetime=2022-01-26>26 January 2022</time><br><time datetime=2022-07-07><span class=has-text-grey-light>Last Updated | 7 July 2022</span></time><br><span class=has-text-grey-light>1466 words | 7 minutes</span></p></div></div></div><div class="tags is-pulled-left"><a class="tag is-primary" href=https://datafortress.cloud/categories/algorithmic-trading/>algorithmic trading</a>
<a class="tag is-primary" href=https://datafortress.cloud/categories/finance/>finance</a></div><div class="tags is-pulled-right"><a class="tag is-info" href=https://datafortress.cloud/tags/algorithmic-trading/>algorithmic trading</a>
<a class="tag is-info" href=https://datafortress.cloud/tags/finance/>finance</a>
<a class="tag is-info" href=https://datafortress.cloud/tags/stocks/>stocks</a>
<a class="tag is-info" href=https://datafortress.cloud/tags/investing/>investing</a>
<a class="tag is-info" href=https://datafortress.cloud/tags/ai-investing/>ai investing</a></div></section><section class=content><h1 id=ihre-ersten-schritte-beim-aufbau-eines-handelsalgorithmus>Ihre ersten Schritte beim Aufbau eines Handelsalgorithmus</h1><p>Nehmen wir an, Sie planen, Ihr eigenes algorithmisches Handelsmodell zu erstellen.</p><p>Sie werden höchstwahrscheinlich nur Preisdaten (Close) für Ihr Modell und Ihren Algorithmus verwenden, aber bald werden Sie feststellen, dass Ihr Modell nicht gut performt.</p><p>Bald werden Sie typische OHLCV-Daten verwenden, die sich auf Open, High, Low, Close, Volume beziehen, was schon besser ist, aber das Modell scheint nicht gut genug zu funktionieren.</p><p>Was können Sie tun?</p><p>Ein praktisches Colab-Notebook zum Mitverfolgen:</p><p><a href="https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing" title="https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing">https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing</a></p><p>Gist:</p><p><a href="https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing" title="https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing">https://gist.github.com/JustinGuese/019e0e71100abe6555f78c32fd0b10a9</a></p><h1 id=wie-mag-ein-machine-learning-trading-bot>Wie mag ein Machine Learning Trading Bot?</h1><p>Der typische maschinelle Lernalgorithmus kann nur mit den Daten arbeiten, die er erhalten hat. Er kann (in der Regel) keine neuen Merkmale oder Interpretationen wie &ldquo;Wenn das Volumen steigt und die 3. Ableitung des Preises steigt, wird der Preis höchstwahrscheinlich steigen&rdquo; erstellen, sondern kann stattdessen nur auf die Daten &ldquo;schauen&rdquo;, die er erhalten hat. Das wären dann Berechnungen wie &ldquo;wenn der Preis über 100 USD liegt und das Volumen über 2000, wird der Preis höchstwahrscheinlich steigen&rdquo;.</p><p>Neulinge im Bereich des maschinellen Lernens versuchen nun, dieses Problem zu lösen, indem sie jahrzehntelang trainieren oder immer mehr GPUs einsetzen, aber ein weitaus effizienterer Weg wäre es, den Algorithmus mit zusätzlichen Daten zu füttern, so dass er mehr Ressourcen für seine Berechnungen nutzen kann.</p><p>Dies kann erreicht werden durch:</p><ol><li>Mehr Daten erhalten (eine größere Zeitspanne)</li><li>Hinzufügen von statistischen Metriken</li><li>Hinzufügen Ihrer eigenen Signale und Interpretationen</li></ol><h1 id=hands-on-anreicherung-ihrer-daten>Hands-on: Anreicherung Ihrer Daten</h1><h2 id=erste-schritte---beschaffung-ihrer-daten>Erste Schritte - Beschaffung Ihrer Daten</h2><p>Lassen Sie uns zunächst einige grundlegende OHLCV-Daten erfassen. Ich mag das yfinance (<a href=https://pypi.org/project/yfinance/ title=https://pypi.org/project/yfinance/>https://pypi.org/project/yfinance/</a>) Modul wegen seiner Einfachheit. Es ist nicht vergleichbar mit Live-Streams von Daten, aber auf der anderen Seite ist es kostenlos und großartig zum Experimentieren!</p><pre><code>pip install yfinance pandas numpy matplotlib ta

import yfinance as yf
import matplotlib.pyplot as plt
import pandas as pd
</code></pre><p>Holen Sie sich einige Bestandsdaten, Intervall und Periode beziehen sich auf die Timerbereiche.</p><p>interval akzeptiert Werte wie 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo</p><p>Periode akzeptiert Werte wie 1d,5d,1mo,3mo,6mo,1y,2y,5y,10y,ytd,max</p><p>Nicht alle Kombinationen funktionieren, z.B. 1m (1 Minute) Intervalle funktionieren nur mit 7d max, 1h (1 Stunde) mit 3 Monaten max (muss als 90d geschrieben werden). Aber lassen Sie uns zuerst mit täglichen Daten arbeiten</p><pre><code>df = yf.download(&quot;MSFT&quot;,period=&quot;5y&quot;,interval=&quot;1d&quot;)
df.head()
</code></pre><p><img src=/images/screenshot-from-2021-01-27-14-46-45.png alt></p><p>Kurzer Exkurs: Was zum Geier ist Open, High, Low, Close, Adj Close und Volume? Wo ist der Preis?!</p><p>Es gibt keinen &ldquo;einen Preis&rdquo; an der Börse! Sie können sich die OHLCV-Daten als &ldquo;Buckets&rdquo; oder &ldquo;Bins&rdquo; in der Zeit vorstellen, die alle Trades zusammenfassen, die in diesem Fenster stattgefunden haben. Das typische &ldquo;Linien&rdquo;-Diagramm, das Sie kennen, bezieht sich normalerweise auf den &ldquo;Close&rdquo;-Kurs dieser Aktie im Zeitbereich X, d.h. den Wert, den die Aktie am Ende des Zeitbereichs hatte.</p><p>Wenn wir uns Tagesdaten ansehen, bezieht sich &ldquo;Open&rdquo; auf den durchschnittlichen (!) Aktienkurs bei Markteröffnung, während &ldquo;Close&rdquo; sich auf den durchschnittlichen (!) Kurs bezieht, den die Aktie bei Marktschluss hatte. Bei stündlichen Daten bezieht sich &ldquo;Open&rdquo; auf den Beginn der jeweiligen Stunde, z. B. 11 Uhr, und &ldquo;Close&rdquo; auf den Schluss der Stunde, also 11:59:59 Uhr.</p><p>Ebenso ist &ldquo;High&rdquo; der höchste Handel/Kurs, der in diesem Zeitrahmen aufgezeichnet wurde, und &ldquo;Low&rdquo; der niedrigste. Das Volumen bezieht sich auf die Anzahl der Assets oder Aktien, die in diesem Zeitbereich gehandelt wurden.</p><p>Das heißt, wenn z.B. &ldquo;Low&rdquo; und &ldquo;Close&rdquo; einer Spalte nahe beieinander liegen, sehen wir höchstwahrscheinlich einen Abwärtstrend, da der Close das aktuelle Low ist. Auch wenn das Volumen hoch ist, gibt es viele Trades, wenn also z.B. das Volumen höher ist als üblich, scheint etwas im Markt zu passieren. Aber wie auch immer, gehen Sie dazu auf <a href=https://www.investopedia.com/, title=https://www.investopedia.com/,>https://www.investopedia.com/,</a> wir werden jetzt mit der Codierung fortfahren!</p><h3 id=was-ist-adj-close>Was ist &ldquo;Adj Close&rdquo;?</h3><p>Dies ist wichtig, da die meisten ML-Algorithmen durch &ldquo;normale&rdquo; Schlussdaten furchtbar verwirrt sind. Wenn es eine Aufspaltung der Aktie gibt, sehen die Daten so aus, als ob der Preis einen irrsinnigen Rückgang hat.</p><p>Der Grund ist, einfach gesagt, dass wenn eine Aktie zu teuer wird, das Unternehmen beschließt, die Aktie in zwei Teile zu &ldquo;teilen&rdquo;. Bedeutet das, dass sich meine Investition halbiert? Natürlich nicht, Sie erhalten einfach die doppelte Menge an Aktien, die Sie halten, so dass Sie auf dem Papier immer noch den gleichen Wert der Aktie halten.</p><p>Interessanterweise führt ein Split in der Regel zu steigenden Kursen (dumme Menschen!), und wenn Ihr maschineller Lernalgorithmus einen enormen Kursverfall sieht, wird er höchstwahrscheinlich die Aktie auf Teufel komm raus verkaufen.</p><p>Aus diesem Grund sollten Sie immer &ldquo;bereinigte&rdquo; Werte verwenden, die man sich als &ldquo;bereinigte&rdquo; Kursdaten vorstellen kann, bei denen Splits, Dividenden und alle anderen Ereignisse, die den wahren Wert der Daten nicht beeinflussen, berücksichtigt werden. Versuchen Sie daher, für Ihre Algorithmen immer bereinigte Daten zu verwenden!</p><p>Im Fall von yfinance ist dies einfach zu bewerkstelligen, da wir einfach &ldquo;Adj Close&rdquo; anstelle von &ldquo;Close&rdquo; verwenden können.</p><h3 id=plotten-der-daten>Plotten der Daten</h3><p>Wenn wir uns die Daten ansehen, können wir bereits eine schöne, bekannte Kurve erkennen</p><pre><code>plt.plot(df[&quot;Adj Close&quot;])
</code></pre><h2 id=schritt-2-anreichern-ihrer-daten-mit-statistischen-daten>Schritt 2: Anreichern Ihrer Daten mit statistischen Daten</h2><p>Wie bereits erwähnt, müssen wir weitere Informationen aus unseren Daten erzeugen, damit der Algorithmus sie verwenden kann, da er dies nicht alleine tun kann.</p><p>Ich verwende gerne die Bibliothek ta (<a href=https://github.com/bukosabino/ta title=https://github.com/bukosabino/ta>https://github.com/bukosabino/ta</a>), da sie wiederum super einfach zu bedienen ist und über 100 statistische Berechnungen enthält.</p><p>Installieren und importieren Sie sie mit</p><pre><code>pip install ta
from ta import add_all_ta_features
from ta.utils import dropna
</code></pre><p>Wenn Sie nun schon wissen, welche Werte Sie verwenden wollen, können Sie nur diese auswählen, ooooder wir schlagen einfach alle 100+ auf unsere Daten ein:</p><pre><code>df = dropna(df) # clean nans if present
df = add_all_ta_features(df,open=&quot;Open&quot;, high=&quot;High&quot;, low=&quot;Low&quot;, close=&quot;Adj Close&quot;, volume=&quot;Volume&quot;)
</code></pre><p>Was haben wir also getan?</p><pre><code>df.columns
Index(['Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume', 'volume_adi',
       'volume_obv', 'volume_cmf', 'volume_fi', 'volume_mfi', 'volume_em',
       'volume_sma_em', 'volume_vpt', 'volume_nvi', 'volume_vwap',
       'volatility_atr', 'volatility_bbm', 'volatility_bbh', 'volatility_bbl',
       'volatility_bbw', 'volatility_bbp', 'volatility_bbhi',
       'volatility_bbli', 'volatility_kcc', 'volatility_kch', 'volatility_kcl',
       'volatility_kcw', 'volatility_kcp', 'volatility_kchi',
       'volatility_kcli', 'volatility_dcl', 'volatility_dch', 'volatility_dcm',
       'volatility_dcw', 'volatility_dcp', 'volatility_ui', 'trend_macd',
       'trend_macd_signal', 'trend_macd_diff', 'trend_sma_fast',
       'trend_sma_slow', 'trend_ema_fast', 'trend_ema_slow', 'trend_adx',
       'trend_adx_pos', 'trend_adx_neg', 'trend_vortex_ind_pos',
       'trend_vortex_ind_neg', 'trend_vortex_ind_diff', 'trend_trix',
       'trend_mass_index', 'trend_cci', 'trend_dpo', 'trend_kst',
       'trend_kst_sig', 'trend_kst_diff', 'trend_ichimoku_conv',
       'trend_ichimoku_base', 'trend_ichimoku_a', 'trend_ichimoku_b',
       'trend_visual_ichimoku_a', 'trend_visual_ichimoku_b', 'trend_aroon_up',
       'trend_aroon_down', 'trend_aroon_ind', 'trend_psar_up',
       'trend_psar_down', 'trend_psar_up_indicator',
       'trend_psar_down_indicator', 'trend_stc', 'momentum_rsi',
       'momentum_stoch_rsi', 'momentum_stoch_rsi_k', 'momentum_stoch_rsi_d',
       'momentum_tsi', 'momentum_uo', 'momentum_stoch',
       'momentum_stoch_signal', 'momentum_wr', 'momentum_ao', 'momentum_kama',
       'momentum_roc', 'momentum_ppo', 'momentum_ppo_signal',
       'momentum_ppo_hist', 'others_dr', 'others_dlr', 'others_cr'],
      dtype='object')
</code></pre><p>Nun, das sollte für den Moment reichen!</p><p>Außerdem ist immer noch eine Menge Nans drin, da einige Werte nur berechnet werden, wenn genug Zeit vergangen ist. Meiner Erfahrung nach funktioniert das Auffüllen mit Nullen ganz gut, auch wenn es dafür fortgeschrittenere Techniken gibt.</p><pre><code>df = df.fillna(0)
</code></pre><h2 id=schritt-3-erstellen-sie-ihre-eigenen-signale>Schritt 3: Erstellen Sie Ihre eigenen Signale</h2><p>Jetzt ist es an der Zeit, Ihre verrückten Handelsideen in Zahlen zu übersetzen!</p><p>Beginnen wir mit dem klassischen Moving Average Cross. Die Idee ist wie folgt: Wenn ein kurzer gleitender Durchschnitt einen langsameren gleitenden Durchschnitt kreuzt, deutet dies entweder auf einen Kursanstieg oder einen Kursrückgang hin, je nach Richtung des Kreuzes.</p><p>Auch hier können Sie bei investopedia Details nachlesen: <a href=https://www.investopedia.com/articles/active-trading/052014/how-use-moving-average-buy-stocks.asp title=https://www.investopedia.com/articles/active-trading/052014/how-use-moving-average-buy-stocks.asp>https://www.investopedia.com/articles/active-trading/052014/how-use-moving-average-buy-stocks.asp</a></p><p>Unser Ziel ist es, zunächst die SMAs zu berechnen und dann die Kreuzungen als 1 und -1 zu formulieren, und 0, um keine Kreuzung zu signalisieren.</p><h3 id=erstellen-einfacher-gleitender-durchschnitte>Erstellen einfacher gleitender Durchschnitte</h3><pre><code># creating simple moving averages
averages = [1,2,5,10,15,20,25,50,100]
for average in averages:
  df['SMA_%d'%average] = df[&quot;Adj Close&quot;].rolling(window=average).mean()

# visualize only SMAs 
filter_col = [col for col in df if col.startswith('SMA')]
df[filter_col].tail()
</code></pre><p>Und Visualisierung:</p><pre><code># results in bigger figures
plt.rcParams[&quot;figure.figsize&quot;] = (20,20)
for filter in filter_col:
  plt.plot(df[filter],label=filter)
plt.legend()
</code></pre><p><img src=/images/download.png alt></p><h3 id=erzeugen-eines-crossover-signals>Erzeugen eines Crossover-Signals</h3><p>Lassen Sie uns eine kleine Hilfsfunktion verwenden</p><pre><code>def createCross(data,fastSMA,slowSMA):
  fast = 'SMA_%d'%fastSMA
  slow = 'SMA_%d'%slowSMA
  crossname = &quot;cross_%d_%d&quot;%(fastSMA,slowSMA)
  previous_fast = data[fast].shift(1)
  previous_slow = data[slow].shift(1)
  neg = ((data[fast] &lt; data[slow]) &amp; (previous_fast &gt;= previous_slow))
  pos = ((data[fast] &gt; data[slow]) &amp; (previous_fast &lt;= previous_slow))
  data[crossname] = 0
  data.loc[neg,crossname] = -1
  data.loc[pos,crossname] = 1
  return data
</code></pre><p>Und nun können Sie entweder eigene Werte einfügen oder unserem Beispiel folgen und einfach die Querprodukte nehmen:</p><pre><code>for fast in averages:
  for slow in averages:
    if fast != slow and slow &gt; fast:
      df = createCross(df,fast,slow)
</code></pre><p>Dadurch wurde ein perfektes Klassifizierungssignal erzeugt, das ein Aufwärtskreuz mit 1 und ein Abwärtskreuz mit -1 signalisiert, wobei 0 ein neutraler Wert (kein Kreuz) ist.</p><p>Dies ist nur ein Beispiel dafür, welche weiteren Signale Sie geben können.</p><h3 id=erstellen-einer-spalte-für-die-prozentuale-veränderung>Erstellen einer Spalte für die prozentuale Veränderung</h3><p>Um ein weiteres Beispiel hinzuzufügen: Wenn Sie versuchen, die prozentuale Veränderung vorherzusagen, benötigen Sie eine Spalte, die die prozentuale Veränderung zum vorherigen Zeitbereich anzeigt. Dies lässt sich glücklicherweise leicht mit Pandas erledigen.</p><pre><code>df[&quot;pct_change&quot;] = df[&quot;Adj Close&quot;].pct_change()

Date
2021-01-21    0.013363
2021-01-22   -0.004463
2021-01-25    0.000538
2021-01-26    0.009754
2021-01-27   -0.010484
Name: pct_change, dtype: float64
</code></pre><p>Was für ein perfektes Signal für ein regressives Modell!</p><h1 id=zusammenfassung>Zusammenfassung</h1><p>Bevor wir unsere Erweiterungen hinzugefügt haben, enthielt der Datenrahmen nur 5 Spalten, nicht viel für ein maschinelles Lernmodell!</p><p>Am Ende, nach dem Hinzufügen von statistischen Werten und unseren eigenen Signalen, haben wir bereits 135 Features und Spalten unseres Datenrahmens erreicht!</p><p>So viel besser für Ihr Modell!</p><p>Was sind Ihre Gedanken zu diesem Prozess? Habe ich etwas übersehen? Möchten Sie mehr Artikel von Justin lesen? Schauen Sie auf meiner Website vorbei und lesen Sie mehr!</p></section></div></div></article><aside class="columns is-centered"><div class="column max-800px"><div class=content><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//datafortess-cloud.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></aside></main><footer class=footer><div class="columns has-text-centered"><div class="column is-one-third is-narrow"><p>Social media</p></div><div class="column is-one-third is-narrow"><i class='fab fa-creative-commons' aria-hidden=true></i> This work is licensed under a <a rel=license href=https://creativecommons.org/licenses/by-sa/4.0/ target=_blank>Creative Commons Attribution-ShareAlike 4.0 International</a> License.</div><div class="column is-one-third is-narrow"><p>Powered by</p><a href=https://gohugo.io/ target=_blank><img src=https://datafortress.cloud/images/hugo-logo.png alt=Hugo width=64 height=12 title="Powered by Hugo"></a> &nbsp; &nbsp;
<a href=https://bulma.io/ target=_blank><img src=https://datafortress.cloud/images/made-with-bulma.png alt=Bulma width=64 height=16 title="Powered by Bulma CSS"></a>&nbsp; &nbsp;
<a href=https://www.gnu.org/software/emacs/ target=_blank><img src=https://datafortress.cloud/images/emacs-logo.png alt=Emacs width=16 height=16 title="Written in Emacs"></a></div></div></footer></body></html>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithmic trading on Datafortress.cloud</title><link>https://datafortress.cloud/de/tags/algorithmic-trading/</link><description>Recent content in algorithmic trading on Datafortress.cloud</description><generator>Hugo -- gohugo.io</generator><language>de-de</language><managingEditor/><webMaster/><lastBuildDate>Mon, 23 May 2022 22:00:00 +0000</lastBuildDate><atom:link href="https://datafortress.cloud/de/tags/algorithmic-trading/index.xml" rel="self" type="application/rss+xml"/><item><title>Howto: Einen automatisierten Machine-Learning Aktienhandels-Roboter mittels AWS Lambda serverlos betreiben</title><link>https://datafortress.cloud/de/blog/howto-einen-automatisierten-machine-learning-aktienhandels-roboter-mittels-aws-lambda-serverlos-betreiben/</link><pubDate>Mon, 23 May 2022 22:00:00 +0000</pubDate><author>Justin Guese</author><guid>https://datafortress.cloud/de/blog/howto-einen-automatisierten-machine-learning-aktienhandels-roboter-mittels-aws-lambda-serverlos-betreiben/</guid><description>
&lt;p>In diesem Beitrag werde ich meinen Algorithmus für serverloses Investieren mit AWS Lambda, Facebook Prophet als ML-Modell und meiner benutzerdefinierten Lambda-Schicht vorstellen.&lt;/p>
&lt;p>Ich habe diesen Beitrag in die Abschnitte &amp;ldquo;Warum habe ich das gemacht&amp;rdquo; und &amp;ldquo;Technisches How To&amp;rdquo; unterteilt. Wenn Sie den &amp;ldquo;Warum&amp;rdquo;-Teil überspringen möchten, können Sie direkt zum technischen Teil springen.&lt;/p>
&lt;h2 id="warum-sollte-ich-ein-maschinelles-lernmodell-in-aws-lambda-einsetzen">Warum sollte ich ein maschinelles Lernmodell in AWS Lambda einsetzen?&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>Die Zuverlässigkeit&lt;/strong>: Der Algorithmus wird unabhängig von anderen Systemen, Updates, &amp;hellip;&lt;/li>
&lt;li>&lt;strong>Leistungseffizienz&lt;/strong>: Ich kann mehrere Algorithmen auf einem (kleinen) System unabhängig voneinander ausführen.&lt;/li>
&lt;li>&lt;strong>Kosteneinsparungen&lt;/strong>: AWS ermöglicht &lt;a href="https://aws.amazon.com/lambda/?did=ft_card&amp;amp;trk=ft_card">3,2 Millionen Rechensekunden pro Monat&lt;/a>, so dass ich im Grunde alle meine Algorithmen kostenlos ausführen kann.&lt;/li>
&lt;/ol>
&lt;p>Ich habe nach einer Möglichkeit gesucht, zunächst sicherzustellen, dass mein Investitions-Bot sicher ausgeführt wird, denn eine fehlgeschlagene Ausführung kann viel Geld kosten, wenn ein Handel nicht umgehend abgebrochen wird, wenn er in die falsche Richtung geht. Außerdem wollte ich vermeiden, meinen Computer die ganze Zeit laufen zu lassen, und sicherstellen, dass mehrere Algorithmen nebeneinander laufen können, ohne ihre Ausführung zu beeinflussen oder zu verzögern.&lt;/p>
&lt;p>Darüber hinaus ist es ein schöner Gedanke, einen investierenden Algorithmus laufen zu lassen, ohne sich um Betriebssystem-Updates, Hardware-Ausfälle und Stromausfälle usw. zu kümmern, was der allgemeine Vorteil serverloser Technologien ist.&lt;/p>
&lt;p>Im Moment kann ich mehrere Variationen des Algorithmus laufen lassen, um Änderungen des Algorithmus zu testen, und kann sicher sein, dass er läuft. Noch eine nette Sache? AWS bietet etwa 1 Million kostenlose Lambda-Aufrufe an, so dass ich die gesamte Architektur in ihrem Free Tier-Kontingent laufen lassen kann.&lt;/p>
&lt;h2 id="der-investitionsalgorithmus">Der Investitionsalgorithmus&lt;/h2>
&lt;p>Ich werde den Algorithmus in einem anderen Beitrag auf meiner Website &lt;a href="">www.datafortress.cloud&lt;/a> ausführlicher erläutern, aber mein typischer Aufbau eines Investitionsalgorithmus besteht aus:&lt;/p>
&lt;ol>
&lt;li>Testen des Algorithmus mit &lt;a href="https://www.backtrader.com/">Backtrader&lt;/a>, einem Open-Source-Backtesting-Framework, das in Python geschrieben wurde&lt;/li>
&lt;li>Konvertieren des erfolgreichen Algorithmus in eine einzelne Python-Datei, die eine run()-Methode enthält, die zurückgibt, welche Investitionen getätigt wurden&lt;/li>
&lt;li>Übertragen der Python-Datei zu AWS Lambda, wo ich die run()-Funktion mit der lambda_handler-Funktion von AWS Lambda aufrufe&lt;/li>
&lt;/ol>
&lt;p>In diesem Beispielalgorithmus treffe ich Investitionsentscheidungen in Abhängigkeit davon, ob der aktuelle Kurs über oder unter der Trendlinie liegt, die vom &lt;a href="https://facebook.github.io/prophet/">Prophetenmodell von Facebook&lt;/a> vorhergesagt wird. Ich habe Ideen von &lt;a href="http://seangtkelley.me/blog/2018/08/15/algo-trading-pt2">Sean Kelley übernommen&lt;/a>, der ein Backtrader-Setup geschrieben hat, wie man Prophet mit Backtrader einsetzen kann.&lt;/p>
&lt;p>Mein Aktienuniversum in diesem Setup wird berechnet, indem ich die 20 besten Aktien aus dem SPY500-Index auswähle, der in den vergangenen X Zeitschritten die höchste Rendite erzielte.&lt;/p>
&lt;p>Die Datenquelle ist Yahoo Finance, unter Verwendung der kostenlosen &lt;a href="">Yfinance-Bibliothek&lt;/a>, und als mein bevorzugter algorithmischer Broker habe ich &lt;a href="https://alpaca.markets/">Alpaca.markets&lt;/a> gewählt.&lt;/p>
&lt;p>In meinem Setup wird der Algorithmus einmal pro Tag um 15 Uhr oder alle 15 Minuten während der Handelszeiten ausgeführt.&lt;/p>
&lt;h2 id="die-probleme-beim-einsatz-des-facebook-propheten-bei-aws-lambda">Die Probleme beim Einsatz des Facebook-Propheten bei AWS Lambda&lt;/h2>
&lt;p>AWS Lambda wird mit einigen Python-Bibliotheken vorinstalliert geliefert, aber wie viele von Ihnen vielleicht wissen, ist dies standardmäßig recht begrenzt (was für Lambda&amp;rsquo;s Versprechen angemessen ist). Dennoch erlaubt Lambda die Installation privater Pakete, was für kleinere Pakete recht einfach ist (siehe die&lt;a href="https://docs.aws.amazon.com/lambda/latest/dg/python-package.html"> offizielle Dokumentation&lt;/a>), aber etwas komplizierter wird, wenn es sich um Pakete handelt, die größer als 250 Mb sind. Unglücklicherweise überschreitet das Prophetenmodell von Facebook diese Grenze, aber glücklicherweise hat &lt;a href="https://towardsdatascience.com/how-to-get-fbprophet-work-on-aws-lambda-c3a33a081aaf">Alexandr Matsenov dieses Problem gelöst&lt;/a>, indem er die Paketgröße reduziert hat, und &lt;a href="https://github.com/marcmetz/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda">Marc Metz hat sich um Kompilierungsprobleme gekümmert, damit es auf AWS Lambda läuft.&lt;/a>&lt;/p>
&lt;p>Nicht standardmäßige Bibliotheken können zu AWS Lambda hinzugefügt werden, indem man Layer verwendet, die alle benötigten Pakete enthalten. Wenn ein Layer importiert wird, können Sie die Pakete einfach in Ihrer Python-Funktion importieren, wie Sie es in Ihrem lokalen Setup tun würden.&lt;/p>
&lt;h1 id="die-technische-anleitung">Die technische Anleitung&lt;/h1>
&lt;p>Lassen Sie mich abschließend erklären, wie genau Sie dies erreichen können. Siehe dieses TLDR für die ungeduldigen Typen oder die detailliertere Version unten.&lt;/p>
&lt;p>&lt;strong>TLDR;&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Sie benötigen ein Lambda-Layer, laden Sie meine (&lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda/raw/master/python.zip">Download&lt;/a>) mit Prophet, yfinance, &amp;hellip; auf einen S3-Bucket (privater Zugang)&lt;/li>
&lt;li>Wählen Sie AWS Lambda, erstellen Sie eine Funktion, fügen Sie ein Layer hinzu und fügen Sie in Ihre S3-Objekt-URL ein&lt;/li>
&lt;li>Fügen Sie Ihre lambda_function.py in den Lambda-Editor ein (&lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda/blob/master/lambda_function.py">oder verwenden Sie meine&lt;/a>)&lt;/li>
&lt;li>Richten Sie Ihre Umgebungsvariablen ein (optional)&lt;/li>
&lt;li>Führen Sie es entweder manuell aus, indem Sie auf &amp;ldquo;Test&amp;rdquo; klicken, oder gehen Sie zu CloudWatch -&amp;gt; Regeln -&amp;gt; Regel erstellen und richten Sie &amp;ldquo;Ausführung planen&amp;rdquo; ein, um es in einem bestimmten Zeitintervall auszuführen&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Ausführliche Erläuterung:&lt;/strong>&lt;/p>
&lt;h2 id="1-erstellen-eines-benutzerdefinierten-layers-für-aws-lambda">1. Erstellen eines benutzerdefinierten Layers für AWS Lambda&lt;/h2>
&lt;p>Sie können entweder mein Lambda-Layer verwenden, die Facebook Prophet, NumPy, Pandas, Alpaka-Handels-API, yfinance (&lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda">GitHub&lt;/a>) enthält, oder Sie können Ihre eigene unter Verwendung der &lt;a href="https://medium.com/@marc.a.metz/docker-run-rm-it-v-pwd-var-task-lambci-lambda-build-python3-7-bash-c7d53f3b7eb2">von Marc gegebenen Erklärung zusammenstellen.&lt;/a>&lt;/p>
&lt;p>&lt;strong>Meine Lambda-Schicht verwenden&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Laden Sie die Zip-Datei von meinem &lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda/raw/master/python.zip">Github-Repo&lt;/a> herunter, die alle Pakete enthält (&lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda/raw/master/python.zip">Link&lt;/a>)&lt;/li>
&lt;li>Da Sie Layer nur bis zu einer Größe von 50 Mb direkt auf Lambda hochladen können, müssen wir die Datei zunächst auf AWS S3 hochladen.&lt;/li>
&lt;li>Erstellen Sie einen Bucket und legen Sie die heruntergeladene Zip-Datei in diesen Eimer. Der Zugang kann privat bleiben und muss NICHT öffentlich sein! Kopieren Sie die URL in Ihre Datei (z.B. &lt;a href="https://BUCKETNAME.s3.REGION.amazonaws.com/python.zip" title="https://BUCKETNAME.s3.REGION.amazonaws.com/python.zip">https://BUCKETNAME.s3.REGION.amazonaws.com/python.zip&lt;/a>)&lt;/li>
&lt;li>Loggen Sie sich in AWS ein und gehen Sie zu Lambda -&amp;gt; Layers (&lt;a href="https://eu-central-1.console.aws.amazon.com/lambda/home?region=eu-central-1#/layers">EU central Link&lt;/a>)&lt;/li>
&lt;li>Klicken Sie auf &amp;ldquo;Layer erstellen&amp;rdquo;, geben Sie ihr einen passenden Namen und wählen Sie &amp;ldquo;Eine Datei von Amazon S3 hochladen&amp;rdquo;, und kopieren Sie den Code von Schritt 3 hinein. Wählen Sie als Runtimes Python 3.7. Klicken Sie auf &amp;ldquo;Erstellen&amp;rdquo;.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Kompilieren Sie Ihre eigenes Lambda-Layer&lt;/strong>&lt;/p>
&lt;p>Bitte folgen Sie den &lt;a href="https://medium.com/@marc.a.metz/docker-run-rm-it-v-pwd-var-task-lambci-lambda-build-python3-7-bash-c7d53f3b7eb2">Anweisungen von Marc&lt;/a>.&lt;/p>
&lt;h2 id="2-erstellen-einer-lambda-funktion">2. Erstellen einer Lambda Funktion&lt;/h2>
&lt;ol>
&lt;li>Öffnen Sie das Dashboard der Lambda-Funktion (&lt;a href="https://eu-central-1.console.aws.amazon.com/lambda/home?region=eu-central-1#/functions">EU central Link&lt;/a>) und klicken Sie auf &amp;ldquo;Funktion erstellen&amp;rdquo;.&lt;/li>
&lt;li>Lassen Sie das Kontrollkästchen &amp;ldquo;Von Grund auf neu&amp;rdquo; unverändert und geben Sie ihm einen passenden Namen.&lt;/li>
&lt;li>Wählen Sie in &amp;ldquo;Runtime&amp;rdquo; Python 3.7, lassen Sie den Rest unverändert und klicken Sie auf &amp;ldquo;Funktion erstellen&amp;rdquo;.&lt;/li>
&lt;li>In der Übersicht der Registerkarte &amp;ldquo;Designer&amp;rdquo; sehen Sie eine grafische Darstellung Ihrer Lambda-Funktion. Klicken Sie auf das Feld &amp;ldquo;Schichten&amp;rdquo; darunter und klicken Sie auf &amp;ldquo;Eine Schicht hinzufügen&amp;rdquo;. Wenn Sie den Layer korrekt eingerichtet haben, können Sie ihn im folgenden Dialog auswählen. Klicken Sie schliesslich auf &amp;ldquo;Hinzufügen&amp;rdquo;.&lt;/li>
&lt;li>In der Registerkarte &amp;ldquo;Designer&amp;rdquo; wählen Sie Ihre Lambda-Funktion aus. Wenn Sie nach unten scrollen, sehen Sie ein Standard-Python-Code-Snippet in einer Datei namens &amp;ldquo;lambda_function.py&amp;rdquo;. Wenn Sie Ihren Code genauso strukturiert haben wie meinen (&lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda/blob/master/lambda_function.py">Link&lt;/a>), können Sie Ihre Funktion mit der run()-Funktion ausführen. Wenn eine Lambda-Funktion aufgerufen wird, wird sie die lambda_handler(event, context)-Funktion ausführen, von der aus Sie z.B. die run()-Funktion aufrufen können. Natürlich können Sie alle Dateien und Funktionen umbenennen, aber der Einfachheit halber habe ich dieses Projekt so belassen, wie es ist.&lt;/li>
&lt;li>Fühlen Sie sich frei, &lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda/blob/master/lambda_function.py">meine Funktion&lt;/a> einfach einzufügen und zu testen.&lt;/li>
&lt;li>Ein Klick auf &amp;ldquo;Test&amp;rdquo; sollte zu einer erfolgreichen Ausführung führen, andernfalls werden die Fehler im Dialog angezeigt.&lt;/li>
&lt;/ol>
&lt;h2 id="3-umgebungsvariabeln-in-aws-lambda-hinzufügen-und-nutzen">3. Umgebungsvariabeln in AWS Lambda hinzufügen und nutzen&lt;/h2>
&lt;p>Sie sollten Ihren Benutzer und Ihr Passwort niemals als Klartext in Ihrem Code hinterlassen, weshalb Sie immer Umgebungsvariablen verwenden sollten! Glücklicherweise verwendet auch Lambda diese, und sie können leicht mit dem Python-OS-Paket aufgerufen werden. In meinem Skript rufe ich z.B. die Benutzervariable mit os.environ[&amp;lsquo;ALPACAUSER&amp;rsquo;] auf. Die Umgebungsvariablen können im Hauptfunktionsbildschirm von Lambda eingerichtet werden, wenn Sie unter Ihrem Code-Editor nach unten scrollen.&lt;/p>
&lt;h2 id="4-aws-lambda-funktionen-in-einem-bestimmten-zeitintervall-auslösen">4. AWS Lambda Funktionen in einem bestimmten Zeitintervall auslösen&lt;/h2>
&lt;p>Das Konzept von Serverless und AWS Lambda basiert auf der Idee, dass eine Funktion ausgeführt wird, wenn ein Trigger-Ereignis eintritt. In meinem Setup wollte ich, dass die Funktion z.B. alle 15 Minuten während der Handelszeiten, Montag bis Freitag, aufgerufen wird. Glücklicherweise bietet AWS eine Möglichkeit, ein Ereignis auszulösen, ohne dass ein Server laufen muss, indem der CloudWatch-Dienst genutzt wird.&lt;/p>
&lt;ol>
&lt;li>Gehen Sie zu CloudWatch (&lt;a href="https://eu-central-1.console.aws.amazon.com/cloudwatch/home?region=eu-central-1">EU central Link&lt;/a>).&lt;/li>
&lt;li>Wählen Sie in der linken Leiste &amp;ldquo;Events&amp;rdquo; und &amp;ldquo;Rule&amp;rdquo;.&lt;/li>
&lt;li>Klicken Sie auf &amp;ldquo;Create Rule&amp;rdquo;, und wählen Sie &amp;ldquo;Schedule&amp;rdquo; anstelle von &amp;ldquo;Event pattern&amp;rdquo;. Hier können Sie den einfachen &amp;ldquo;Fixed-rate&amp;rdquo;-Dialog verwenden oder einen Cron-Ausdruck erstellen. Ich benutze &lt;a href="https://crontab.guru/" title="https://crontab.guru/">https://crontab.guru/&lt;/a> (kostenlos), um Cron-Ausdrücke zu erstellen. Mein Cron-Ausdruck für den oben erwähnten Anwendungsfall lautet &amp;ldquo;0/15 13-21 ? * MON-FRI *&amp;rdquo;.&lt;/li>
&lt;li>Wählen Sie in der rechten Tafel &amp;ldquo;Add Target&amp;rdquo; und wählen Sie Ihre Lambda-Funktion. Sie wird automatisch zu Lambda hinzugefügt.&lt;/li>
&lt;li>Klicken Sie schließlich auf &amp;ldquo;Details konfigurieren&amp;rdquo;, geben Sie ihr einen Namen und klicken Sie auf &amp;ldquo;Regel erstellen&amp;rdquo;.&lt;/li>
&lt;/ol>
&lt;h2 id="5-optional-log-analysen-errorsuche">5. (optional) Log Analysen, Errorsuche&lt;/h2>
&lt;p>Wenn Sie es bis zu diesem Teil geschafft haben, sollten Sie fertig sein! Wenn Sie aber überprüfen wollen, ob alles funktioniert hat, können Sie mit CloudWatch einen Blick auf die Ausgaben der Lambda-Funktionen werfen. Gehen Sie zu CloudWatch -&amp;gt; Logs -&amp;gt; Log-Gruppen (&lt;a href="https://eu-central-1.console.aws.amazon.com/cloudwatch/home?region=eu-central-1#logsV2:log-groups">EU central Link&lt;/a>) und wählen Sie Ihre Lambda-Funktion aus. In dieser Übersicht sollten Sie die Ausgaben Ihrer Funktionen sehen können.&lt;/p>
&lt;p>Wenn Ihnen dieser Beitrag gefallen hat, hinterlassen Sie einen Kommentar oder schauen Sie sich andere Beiträge an, um mich weiterhin zum Schreiben zu motivieren 😊.&lt;/p></description></item><item><title>Anreichern von Aktiendaten für Ihr algorithmisches Python-Handelsmodell</title><link>https://datafortress.cloud/de/blog/anreichern-von-aktiendaten-fur-ihr-algorithmisches-python-handelsmodell/</link><pubDate>Wed, 26 Jan 2022 23:00:00 +0000</pubDate><author>Justin Guese</author><guid>https://datafortress.cloud/de/blog/anreichern-von-aktiendaten-fur-ihr-algorithmisches-python-handelsmodell/</guid><description>
&lt;h1 id="ihre-ersten-schritte-beim-aufbau-eines-handelsalgorithmus">Ihre ersten Schritte beim Aufbau eines Handelsalgorithmus&lt;/h1>
&lt;p>Nehmen wir an, Sie planen, Ihr eigenes algorithmisches Handelsmodell zu erstellen.&lt;/p>
&lt;p>Sie werden höchstwahrscheinlich nur Preisdaten (Close) für Ihr Modell und Ihren Algorithmus verwenden, aber bald werden Sie feststellen, dass Ihr Modell nicht gut performt.&lt;/p>
&lt;p>Bald werden Sie typische OHLCV-Daten verwenden, die sich auf Open, High, Low, Close, Volume beziehen, was schon besser ist, aber das Modell scheint nicht gut genug zu funktionieren.&lt;/p>
&lt;p>Was können Sie tun?&lt;/p>
&lt;p>Ein praktisches Colab-Notebook zum Mitverfolgen:&lt;/p>
&lt;p>&lt;a href="https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing" title="https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing">https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing&lt;/a>&lt;/p>
&lt;p>Gist:&lt;/p>
&lt;p>&lt;a href="https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing" title="https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing">https://gist.github.com/JustinGuese/019e0e71100abe6555f78c32fd0b10a9&lt;/a>&lt;/p>
&lt;h1 id="wie-mag-ein-machine-learning-trading-bot">Wie mag ein Machine Learning Trading Bot?&lt;/h1>
&lt;p>Der typische maschinelle Lernalgorithmus kann nur mit den Daten arbeiten, die er erhalten hat. Er kann (in der Regel) keine neuen Merkmale oder Interpretationen wie &amp;ldquo;Wenn das Volumen steigt und die 3. Ableitung des Preises steigt, wird der Preis höchstwahrscheinlich steigen&amp;rdquo; erstellen, sondern kann stattdessen nur auf die Daten &amp;ldquo;schauen&amp;rdquo;, die er erhalten hat. Das wären dann Berechnungen wie &amp;ldquo;wenn der Preis über 100 USD liegt und das Volumen über 2000, wird der Preis höchstwahrscheinlich steigen&amp;rdquo;.&lt;/p>
&lt;p>Neulinge im Bereich des maschinellen Lernens versuchen nun, dieses Problem zu lösen, indem sie jahrzehntelang trainieren oder immer mehr GPUs einsetzen, aber ein weitaus effizienterer Weg wäre es, den Algorithmus mit zusätzlichen Daten zu füttern, so dass er mehr Ressourcen für seine Berechnungen nutzen kann.&lt;/p>
&lt;p>Dies kann erreicht werden durch:&lt;/p>
&lt;ol>
&lt;li>Mehr Daten erhalten (eine größere Zeitspanne)&lt;/li>
&lt;li>Hinzufügen von statistischen Metriken&lt;/li>
&lt;li>Hinzufügen Ihrer eigenen Signale und Interpretationen&lt;/li>
&lt;/ol>
&lt;h1 id="hands-on-anreicherung-ihrer-daten">Hands-on: Anreicherung Ihrer Daten&lt;/h1>
&lt;h2 id="erste-schritte---beschaffung-ihrer-daten">Erste Schritte - Beschaffung Ihrer Daten&lt;/h2>
&lt;p>Lassen Sie uns zunächst einige grundlegende OHLCV-Daten erfassen. Ich mag das yfinance (&lt;a href="https://pypi.org/project/yfinance/" title="https://pypi.org/project/yfinance/">https://pypi.org/project/yfinance/&lt;/a>) Modul wegen seiner Einfachheit. Es ist nicht vergleichbar mit Live-Streams von Daten, aber auf der anderen Seite ist es kostenlos und großartig zum Experimentieren!&lt;/p>
&lt;pre>&lt;code>pip install yfinance pandas numpy matplotlib ta
import yfinance as yf
import matplotlib.pyplot as plt
import pandas as pd
&lt;/code>&lt;/pre>
&lt;p>Holen Sie sich einige Bestandsdaten, Intervall und Periode beziehen sich auf die Timerbereiche.&lt;/p>
&lt;p>interval akzeptiert Werte wie 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo&lt;/p>
&lt;p>Periode akzeptiert Werte wie 1d,5d,1mo,3mo,6mo,1y,2y,5y,10y,ytd,max&lt;/p>
&lt;p>Nicht alle Kombinationen funktionieren, z.B. 1m (1 Minute) Intervalle funktionieren nur mit 7d max, 1h (1 Stunde) mit 3 Monaten max (muss als 90d geschrieben werden). Aber lassen Sie uns zuerst mit täglichen Daten arbeiten&lt;/p>
&lt;pre>&lt;code>df = yf.download(&amp;quot;MSFT&amp;quot;,period=&amp;quot;5y&amp;quot;,interval=&amp;quot;1d&amp;quot;)
df.head()
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://datafortress.cloud/images/screenshot-from-2021-01-27-14-46-45.png" alt="">&lt;/p>
&lt;p>Kurzer Exkurs: Was zum Geier ist Open, High, Low, Close, Adj Close und Volume? Wo ist der Preis?!&lt;/p>
&lt;p>Es gibt keinen &amp;ldquo;einen Preis&amp;rdquo; an der Börse! Sie können sich die OHLCV-Daten als &amp;ldquo;Buckets&amp;rdquo; oder &amp;ldquo;Bins&amp;rdquo; in der Zeit vorstellen, die alle Trades zusammenfassen, die in diesem Fenster stattgefunden haben. Das typische &amp;ldquo;Linien&amp;rdquo;-Diagramm, das Sie kennen, bezieht sich normalerweise auf den &amp;ldquo;Close&amp;rdquo;-Kurs dieser Aktie im Zeitbereich X, d.h. den Wert, den die Aktie am Ende des Zeitbereichs hatte.&lt;/p>
&lt;p>Wenn wir uns Tagesdaten ansehen, bezieht sich &amp;ldquo;Open&amp;rdquo; auf den durchschnittlichen (!) Aktienkurs bei Markteröffnung, während &amp;ldquo;Close&amp;rdquo; sich auf den durchschnittlichen (!) Kurs bezieht, den die Aktie bei Marktschluss hatte. Bei stündlichen Daten bezieht sich &amp;ldquo;Open&amp;rdquo; auf den Beginn der jeweiligen Stunde, z. B. 11 Uhr, und &amp;ldquo;Close&amp;rdquo; auf den Schluss der Stunde, also 11:59:59 Uhr.&lt;/p>
&lt;p>Ebenso ist &amp;ldquo;High&amp;rdquo; der höchste Handel/Kurs, der in diesem Zeitrahmen aufgezeichnet wurde, und &amp;ldquo;Low&amp;rdquo; der niedrigste. Das Volumen bezieht sich auf die Anzahl der Assets oder Aktien, die in diesem Zeitbereich gehandelt wurden.&lt;/p>
&lt;p>Das heißt, wenn z.B. &amp;ldquo;Low&amp;rdquo; und &amp;ldquo;Close&amp;rdquo; einer Spalte nahe beieinander liegen, sehen wir höchstwahrscheinlich einen Abwärtstrend, da der Close das aktuelle Low ist. Auch wenn das Volumen hoch ist, gibt es viele Trades, wenn also z.B. das Volumen höher ist als üblich, scheint etwas im Markt zu passieren. Aber wie auch immer, gehen Sie dazu auf &lt;a href="https://www.investopedia.com/," title="https://www.investopedia.com/,">https://www.investopedia.com/,&lt;/a> wir werden jetzt mit der Codierung fortfahren!&lt;/p>
&lt;h3 id="was-ist-adj-close">Was ist &amp;ldquo;Adj Close&amp;rdquo;?&lt;/h3>
&lt;p>Dies ist wichtig, da die meisten ML-Algorithmen durch &amp;ldquo;normale&amp;rdquo; Schlussdaten furchtbar verwirrt sind. Wenn es eine Aufspaltung der Aktie gibt, sehen die Daten so aus, als ob der Preis einen irrsinnigen Rückgang hat.&lt;/p>
&lt;p>Der Grund ist, einfach gesagt, dass wenn eine Aktie zu teuer wird, das Unternehmen beschließt, die Aktie in zwei Teile zu &amp;ldquo;teilen&amp;rdquo;. Bedeutet das, dass sich meine Investition halbiert? Natürlich nicht, Sie erhalten einfach die doppelte Menge an Aktien, die Sie halten, so dass Sie auf dem Papier immer noch den gleichen Wert der Aktie halten.&lt;/p>
&lt;p>Interessanterweise führt ein Split in der Regel zu steigenden Kursen (dumme Menschen!), und wenn Ihr maschineller Lernalgorithmus einen enormen Kursverfall sieht, wird er höchstwahrscheinlich die Aktie auf Teufel komm raus verkaufen.&lt;/p>
&lt;p>Aus diesem Grund sollten Sie immer &amp;ldquo;bereinigte&amp;rdquo; Werte verwenden, die man sich als &amp;ldquo;bereinigte&amp;rdquo; Kursdaten vorstellen kann, bei denen Splits, Dividenden und alle anderen Ereignisse, die den wahren Wert der Daten nicht beeinflussen, berücksichtigt werden. Versuchen Sie daher, für Ihre Algorithmen immer bereinigte Daten zu verwenden!&lt;/p>
&lt;p>Im Fall von yfinance ist dies einfach zu bewerkstelligen, da wir einfach &amp;ldquo;Adj Close&amp;rdquo; anstelle von &amp;ldquo;Close&amp;rdquo; verwenden können.&lt;/p>
&lt;h3 id="plotten-der-daten">Plotten der Daten&lt;/h3>
&lt;p>Wenn wir uns die Daten ansehen, können wir bereits eine schöne, bekannte Kurve erkennen&lt;/p>
&lt;pre>&lt;code>plt.plot(df[&amp;quot;Adj Close&amp;quot;])
&lt;/code>&lt;/pre>
&lt;h2 id="schritt-2-anreichern-ihrer-daten-mit-statistischen-daten">Schritt 2: Anreichern Ihrer Daten mit statistischen Daten&lt;/h2>
&lt;p>Wie bereits erwähnt, müssen wir weitere Informationen aus unseren Daten erzeugen, damit der Algorithmus sie verwenden kann, da er dies nicht alleine tun kann.&lt;/p>
&lt;p>Ich verwende gerne die Bibliothek ta (&lt;a href="https://github.com/bukosabino/ta" title="https://github.com/bukosabino/ta">https://github.com/bukosabino/ta&lt;/a>), da sie wiederum super einfach zu bedienen ist und über 100 statistische Berechnungen enthält.&lt;/p>
&lt;p>Installieren und importieren Sie sie mit&lt;/p>
&lt;pre>&lt;code>pip install ta
from ta import add_all_ta_features
from ta.utils import dropna
&lt;/code>&lt;/pre>
&lt;p>Wenn Sie nun schon wissen, welche Werte Sie verwenden wollen, können Sie nur diese auswählen, ooooder wir schlagen einfach alle 100+ auf unsere Daten ein:&lt;/p>
&lt;pre>&lt;code>df = dropna(df) # clean nans if present
df = add_all_ta_features(df,open=&amp;quot;Open&amp;quot;, high=&amp;quot;High&amp;quot;, low=&amp;quot;Low&amp;quot;, close=&amp;quot;Adj Close&amp;quot;, volume=&amp;quot;Volume&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>Was haben wir also getan?&lt;/p>
&lt;pre>&lt;code>df.columns
Index(['Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume', 'volume_adi',
'volume_obv', 'volume_cmf', 'volume_fi', 'volume_mfi', 'volume_em',
'volume_sma_em', 'volume_vpt', 'volume_nvi', 'volume_vwap',
'volatility_atr', 'volatility_bbm', 'volatility_bbh', 'volatility_bbl',
'volatility_bbw', 'volatility_bbp', 'volatility_bbhi',
'volatility_bbli', 'volatility_kcc', 'volatility_kch', 'volatility_kcl',
'volatility_kcw', 'volatility_kcp', 'volatility_kchi',
'volatility_kcli', 'volatility_dcl', 'volatility_dch', 'volatility_dcm',
'volatility_dcw', 'volatility_dcp', 'volatility_ui', 'trend_macd',
'trend_macd_signal', 'trend_macd_diff', 'trend_sma_fast',
'trend_sma_slow', 'trend_ema_fast', 'trend_ema_slow', 'trend_adx',
'trend_adx_pos', 'trend_adx_neg', 'trend_vortex_ind_pos',
'trend_vortex_ind_neg', 'trend_vortex_ind_diff', 'trend_trix',
'trend_mass_index', 'trend_cci', 'trend_dpo', 'trend_kst',
'trend_kst_sig', 'trend_kst_diff', 'trend_ichimoku_conv',
'trend_ichimoku_base', 'trend_ichimoku_a', 'trend_ichimoku_b',
'trend_visual_ichimoku_a', 'trend_visual_ichimoku_b', 'trend_aroon_up',
'trend_aroon_down', 'trend_aroon_ind', 'trend_psar_up',
'trend_psar_down', 'trend_psar_up_indicator',
'trend_psar_down_indicator', 'trend_stc', 'momentum_rsi',
'momentum_stoch_rsi', 'momentum_stoch_rsi_k', 'momentum_stoch_rsi_d',
'momentum_tsi', 'momentum_uo', 'momentum_stoch',
'momentum_stoch_signal', 'momentum_wr', 'momentum_ao', 'momentum_kama',
'momentum_roc', 'momentum_ppo', 'momentum_ppo_signal',
'momentum_ppo_hist', 'others_dr', 'others_dlr', 'others_cr'],
dtype='object')
&lt;/code>&lt;/pre>
&lt;p>Nun, das sollte für den Moment reichen!&lt;/p>
&lt;p>Außerdem ist immer noch eine Menge Nans drin, da einige Werte nur berechnet werden, wenn genug Zeit vergangen ist. Meiner Erfahrung nach funktioniert das Auffüllen mit Nullen ganz gut, auch wenn es dafür fortgeschrittenere Techniken gibt.&lt;/p>
&lt;pre>&lt;code>df = df.fillna(0)
&lt;/code>&lt;/pre>
&lt;h2 id="schritt-3-erstellen-sie-ihre-eigenen-signale">Schritt 3: Erstellen Sie Ihre eigenen Signale&lt;/h2>
&lt;p>Jetzt ist es an der Zeit, Ihre verrückten Handelsideen in Zahlen zu übersetzen!&lt;/p>
&lt;p>Beginnen wir mit dem klassischen Moving Average Cross. Die Idee ist wie folgt: Wenn ein kurzer gleitender Durchschnitt einen langsameren gleitenden Durchschnitt kreuzt, deutet dies entweder auf einen Kursanstieg oder einen Kursrückgang hin, je nach Richtung des Kreuzes.&lt;/p>
&lt;p>Auch hier können Sie bei investopedia Details nachlesen: &lt;a href="https://www.investopedia.com/articles/active-trading/052014/how-use-moving-average-buy-stocks.asp" title="https://www.investopedia.com/articles/active-trading/052014/how-use-moving-average-buy-stocks.asp">https://www.investopedia.com/articles/active-trading/052014/how-use-moving-average-buy-stocks.asp&lt;/a>&lt;/p>
&lt;p>Unser Ziel ist es, zunächst die SMAs zu berechnen und dann die Kreuzungen als 1 und -1 zu formulieren, und 0, um keine Kreuzung zu signalisieren.&lt;/p>
&lt;h3 id="erstellen-einfacher-gleitender-durchschnitte">Erstellen einfacher gleitender Durchschnitte&lt;/h3>
&lt;pre>&lt;code># creating simple moving averages
averages = [1,2,5,10,15,20,25,50,100]
for average in averages:
df['SMA_%d'%average] = df[&amp;quot;Adj Close&amp;quot;].rolling(window=average).mean()
# visualize only SMAs
filter_col = [col for col in df if col.startswith('SMA')]
df[filter_col].tail()
&lt;/code>&lt;/pre>
&lt;p>Und Visualisierung:&lt;/p>
&lt;pre>&lt;code># results in bigger figures
plt.rcParams[&amp;quot;figure.figsize&amp;quot;] = (20,20)
for filter in filter_col:
plt.plot(df[filter],label=filter)
plt.legend()
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://datafortress.cloud/images/download.png" alt="">&lt;/p>
&lt;h3 id="erzeugen-eines-crossover-signals">Erzeugen eines Crossover-Signals&lt;/h3>
&lt;p>Lassen Sie uns eine kleine Hilfsfunktion verwenden&lt;/p>
&lt;pre>&lt;code>def createCross(data,fastSMA,slowSMA):
fast = 'SMA_%d'%fastSMA
slow = 'SMA_%d'%slowSMA
crossname = &amp;quot;cross_%d_%d&amp;quot;%(fastSMA,slowSMA)
previous_fast = data[fast].shift(1)
previous_slow = data[slow].shift(1)
neg = ((data[fast] &amp;lt; data[slow]) &amp;amp; (previous_fast &amp;gt;= previous_slow))
pos = ((data[fast] &amp;gt; data[slow]) &amp;amp; (previous_fast &amp;lt;= previous_slow))
data[crossname] = 0
data.loc[neg,crossname] = -1
data.loc[pos,crossname] = 1
return data
&lt;/code>&lt;/pre>
&lt;p>Und nun können Sie entweder eigene Werte einfügen oder unserem Beispiel folgen und einfach die Querprodukte nehmen:&lt;/p>
&lt;pre>&lt;code>for fast in averages:
for slow in averages:
if fast != slow and slow &amp;gt; fast:
df = createCross(df,fast,slow)
&lt;/code>&lt;/pre>
&lt;p>Dadurch wurde ein perfektes Klassifizierungssignal erzeugt, das ein Aufwärtskreuz mit 1 und ein Abwärtskreuz mit -1 signalisiert, wobei 0 ein neutraler Wert (kein Kreuz) ist.&lt;/p>
&lt;p>Dies ist nur ein Beispiel dafür, welche weiteren Signale Sie geben können.&lt;/p>
&lt;h3 id="erstellen-einer-spalte-für-die-prozentuale-veränderung">Erstellen einer Spalte für die prozentuale Veränderung&lt;/h3>
&lt;p>Um ein weiteres Beispiel hinzuzufügen: Wenn Sie versuchen, die prozentuale Veränderung vorherzusagen, benötigen Sie eine Spalte, die die prozentuale Veränderung zum vorherigen Zeitbereich anzeigt. Dies lässt sich glücklicherweise leicht mit Pandas erledigen.&lt;/p>
&lt;pre>&lt;code>df[&amp;quot;pct_change&amp;quot;] = df[&amp;quot;Adj Close&amp;quot;].pct_change()
Date
2021-01-21 0.013363
2021-01-22 -0.004463
2021-01-25 0.000538
2021-01-26 0.009754
2021-01-27 -0.010484
Name: pct_change, dtype: float64
&lt;/code>&lt;/pre>
&lt;p>Was für ein perfektes Signal für ein regressives Modell!&lt;/p>
&lt;h1 id="zusammenfassung">Zusammenfassung&lt;/h1>
&lt;p>Bevor wir unsere Erweiterungen hinzugefügt haben, enthielt der Datenrahmen nur 5 Spalten, nicht viel für ein maschinelles Lernmodell!&lt;/p>
&lt;p>Am Ende, nach dem Hinzufügen von statistischen Werten und unseren eigenen Signalen, haben wir bereits 135 Features und Spalten unseres Datenrahmens erreicht!&lt;/p>
&lt;p>So viel besser für Ihr Modell!&lt;/p>
&lt;p>Was sind Ihre Gedanken zu diesem Prozess? Habe ich etwas übersehen? Möchten Sie mehr Artikel von Justin lesen? Schauen Sie auf meiner Website vorbei und lesen Sie mehr!&lt;/p></description></item></channel></rss>
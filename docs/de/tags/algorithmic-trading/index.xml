<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithmic trading on Datafortress.cloud</title><link>https://datafortress.cloud/de/tags/algorithmic-trading/</link><description>Recent content in algorithmic trading on Datafortress.cloud</description><generator>Hugo -- gohugo.io</generator><language>de-de</language><managingEditor/><webMaster/><lastBuildDate>Mon, 23 May 2022 22:00:00 +0000</lastBuildDate><atom:link href="https://datafortress.cloud/de/tags/algorithmic-trading/index.xml" rel="self" type="application/rss+xml"/><item><title>Howto: Einen automatisierten Machine-Learning Aktienhandels-Roboter mittels AWS Lambda serverlos betreiben</title><link>https://datafortress.cloud/de/blog/howto-einen-automatisierten-machine-learning-aktienhandels-roboter-mittels-aws-lambda-serverlos-betreiben/</link><pubDate>Mon, 23 May 2022 22:00:00 +0000</pubDate><author>Justin Guese</author><guid>https://datafortress.cloud/de/blog/howto-einen-automatisierten-machine-learning-aktienhandels-roboter-mittels-aws-lambda-serverlos-betreiben/</guid><description>
&lt;p>In diesem Beitrag werde ich meinen Algorithmus f√ºr serverloses Investieren mit AWS Lambda, Facebook Prophet als ML-Modell und meiner benutzerdefinierten Lambda-Schicht vorstellen.&lt;/p>
&lt;p>Ich habe diesen Beitrag in die Abschnitte &amp;ldquo;Warum habe ich das gemacht&amp;rdquo; und &amp;ldquo;Technisches How To&amp;rdquo; unterteilt. Wenn Sie den &amp;ldquo;Warum&amp;rdquo;-Teil √ºberspringen m√∂chten, k√∂nnen Sie direkt zum technischen Teil springen.&lt;/p>
&lt;h2 id="warum-sollte-ich-ein-maschinelles-lernmodell-in-aws-lambda-einsetzen">Warum sollte ich ein maschinelles Lernmodell in AWS Lambda einsetzen?&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>Die Zuverl√§ssigkeit&lt;/strong>: Der Algorithmus wird unabh√§ngig von anderen Systemen, Updates, &amp;hellip;&lt;/li>
&lt;li>&lt;strong>Leistungseffizienz&lt;/strong>: Ich kann mehrere Algorithmen auf einem (kleinen) System unabh√§ngig voneinander ausf√ºhren.&lt;/li>
&lt;li>&lt;strong>Kosteneinsparungen&lt;/strong>: AWS erm√∂glicht &lt;a href="https://aws.amazon.com/lambda/?did=ft_card&amp;amp;trk=ft_card">3,2 Millionen Rechensekunden pro Monat&lt;/a>, so dass ich im Grunde alle meine Algorithmen kostenlos ausf√ºhren kann.&lt;/li>
&lt;/ol>
&lt;p>Ich habe nach einer M√∂glichkeit gesucht, zun√§chst sicherzustellen, dass mein Investitions-Bot sicher ausgef√ºhrt wird, denn eine fehlgeschlagene Ausf√ºhrung kann viel Geld kosten, wenn ein Handel nicht umgehend abgebrochen wird, wenn er in die falsche Richtung geht. Au√üerdem wollte ich vermeiden, meinen Computer die ganze Zeit laufen zu lassen, und sicherstellen, dass mehrere Algorithmen nebeneinander laufen k√∂nnen, ohne ihre Ausf√ºhrung zu beeinflussen oder zu verz√∂gern.&lt;/p>
&lt;p>Dar√ºber hinaus ist es ein sch√∂ner Gedanke, einen investierenden Algorithmus laufen zu lassen, ohne sich um Betriebssystem-Updates, Hardware-Ausf√§lle und Stromausf√§lle usw. zu k√ºmmern, was der allgemeine Vorteil serverloser Technologien ist.&lt;/p>
&lt;p>Im Moment kann ich mehrere Variationen des Algorithmus laufen lassen, um √Ñnderungen des Algorithmus zu testen, und kann sicher sein, dass er l√§uft. Noch eine nette Sache? AWS bietet etwa 1 Million kostenlose Lambda-Aufrufe an, so dass ich die gesamte Architektur in ihrem Free Tier-Kontingent laufen lassen kann.&lt;/p>
&lt;h2 id="der-investitionsalgorithmus">Der Investitionsalgorithmus&lt;/h2>
&lt;p>Ich werde den Algorithmus in einem anderen Beitrag auf meiner Website &lt;a href="">www.datafortress.cloud&lt;/a> ausf√ºhrlicher erl√§utern, aber mein typischer Aufbau eines Investitionsalgorithmus besteht aus:&lt;/p>
&lt;ol>
&lt;li>Testen des Algorithmus mit &lt;a href="https://www.backtrader.com/">Backtrader&lt;/a>, einem Open-Source-Backtesting-Framework, das in Python geschrieben wurde&lt;/li>
&lt;li>Konvertieren des erfolgreichen Algorithmus in eine einzelne Python-Datei, die eine run()-Methode enth√§lt, die zur√ºckgibt, welche Investitionen get√§tigt wurden&lt;/li>
&lt;li>√úbertragen der Python-Datei zu AWS Lambda, wo ich die run()-Funktion mit der lambda_handler-Funktion von AWS Lambda aufrufe&lt;/li>
&lt;/ol>
&lt;p>In diesem Beispielalgorithmus treffe ich Investitionsentscheidungen in Abh√§ngigkeit davon, ob der aktuelle Kurs √ºber oder unter der Trendlinie liegt, die vom &lt;a href="https://facebook.github.io/prophet/">Prophetenmodell von Facebook&lt;/a> vorhergesagt wird. Ich habe Ideen von &lt;a href="http://seangtkelley.me/blog/2018/08/15/algo-trading-pt2">Sean Kelley √ºbernommen&lt;/a>, der ein Backtrader-Setup geschrieben hat, wie man Prophet mit Backtrader einsetzen kann.&lt;/p>
&lt;p>Mein Aktienuniversum in diesem Setup wird berechnet, indem ich die 20 besten Aktien aus dem SPY500-Index ausw√§hle, der in den vergangenen X Zeitschritten die h√∂chste Rendite erzielte.&lt;/p>
&lt;p>Die Datenquelle ist Yahoo Finance, unter Verwendung der kostenlosen &lt;a href="">Yfinance-Bibliothek&lt;/a>, und als mein bevorzugter algorithmischer Broker habe ich &lt;a href="https://alpaca.markets/">Alpaca.markets&lt;/a> gew√§hlt.&lt;/p>
&lt;p>In meinem Setup wird der Algorithmus einmal pro Tag um 15 Uhr oder alle 15 Minuten w√§hrend der Handelszeiten ausgef√ºhrt.&lt;/p>
&lt;h2 id="die-probleme-beim-einsatz-des-facebook-propheten-bei-aws-lambda">Die Probleme beim Einsatz des Facebook-Propheten bei AWS Lambda&lt;/h2>
&lt;p>AWS Lambda wird mit einigen Python-Bibliotheken vorinstalliert geliefert, aber wie viele von Ihnen vielleicht wissen, ist dies standardm√§√üig recht begrenzt (was f√ºr Lambda&amp;rsquo;s Versprechen angemessen ist). Dennoch erlaubt Lambda die Installation privater Pakete, was f√ºr kleinere Pakete recht einfach ist (siehe die&lt;a href="https://docs.aws.amazon.com/lambda/latest/dg/python-package.html"> offizielle Dokumentation&lt;/a>), aber etwas komplizierter wird, wenn es sich um Pakete handelt, die gr√∂√üer als 250 Mb sind. Ungl√ºcklicherweise √ºberschreitet das Prophetenmodell von Facebook diese Grenze, aber gl√ºcklicherweise hat &lt;a href="https://towardsdatascience.com/how-to-get-fbprophet-work-on-aws-lambda-c3a33a081aaf">Alexandr Matsenov dieses Problem gel√∂st&lt;/a>, indem er die Paketgr√∂√üe reduziert hat, und &lt;a href="https://github.com/marcmetz/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda">Marc Metz hat sich um Kompilierungsprobleme gek√ºmmert, damit es auf AWS Lambda l√§uft.&lt;/a>&lt;/p>
&lt;p>Nicht standardm√§√üige Bibliotheken k√∂nnen zu AWS Lambda hinzugef√ºgt werden, indem man Layer verwendet, die alle ben√∂tigten Pakete enthalten. Wenn ein Layer importiert wird, k√∂nnen Sie die Pakete einfach in Ihrer Python-Funktion importieren, wie Sie es in Ihrem lokalen Setup tun w√ºrden.&lt;/p>
&lt;h1 id="die-technische-anleitung">Die technische Anleitung&lt;/h1>
&lt;p>Lassen Sie mich abschlie√üend erkl√§ren, wie genau Sie dies erreichen k√∂nnen. Siehe dieses TLDR f√ºr die ungeduldigen Typen oder die detailliertere Version unten.&lt;/p>
&lt;p>&lt;strong>TLDR;&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Sie ben√∂tigen ein Lambda-Layer, laden Sie meine (&lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda/raw/master/python.zip">Download&lt;/a>) mit Prophet, yfinance, &amp;hellip; auf einen S3-Bucket (privater Zugang)&lt;/li>
&lt;li>W√§hlen Sie AWS Lambda, erstellen Sie eine Funktion, f√ºgen Sie ein Layer hinzu und f√ºgen Sie in Ihre S3-Objekt-URL ein&lt;/li>
&lt;li>F√ºgen Sie Ihre lambda_function.py in den Lambda-Editor ein (&lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda/blob/master/lambda_function.py">oder verwenden Sie meine&lt;/a>)&lt;/li>
&lt;li>Richten Sie Ihre Umgebungsvariablen ein (optional)&lt;/li>
&lt;li>F√ºhren Sie es entweder manuell aus, indem Sie auf &amp;ldquo;Test&amp;rdquo; klicken, oder gehen Sie zu CloudWatch -&amp;gt; Regeln -&amp;gt; Regel erstellen und richten Sie &amp;ldquo;Ausf√ºhrung planen&amp;rdquo; ein, um es in einem bestimmten Zeitintervall auszuf√ºhren&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Ausf√ºhrliche Erl√§uterung:&lt;/strong>&lt;/p>
&lt;h2 id="1-erstellen-eines-benutzerdefinierten-layers-f√ºr-aws-lambda">1. Erstellen eines benutzerdefinierten Layers f√ºr AWS Lambda&lt;/h2>
&lt;p>Sie k√∂nnen entweder mein Lambda-Layer verwenden, die Facebook Prophet, NumPy, Pandas, Alpaka-Handels-API, yfinance (&lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda">GitHub&lt;/a>) enth√§lt, oder Sie k√∂nnen Ihre eigene unter Verwendung der &lt;a href="https://medium.com/@marc.a.metz/docker-run-rm-it-v-pwd-var-task-lambci-lambda-build-python3-7-bash-c7d53f3b7eb2">von Marc gegebenen Erkl√§rung zusammenstellen.&lt;/a>&lt;/p>
&lt;p>&lt;strong>Meine Lambda-Schicht verwenden&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Laden Sie die Zip-Datei von meinem &lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda/raw/master/python.zip">Github-Repo&lt;/a> herunter, die alle Pakete enth√§lt (&lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda/raw/master/python.zip">Link&lt;/a>)&lt;/li>
&lt;li>Da Sie Layer nur bis zu einer Gr√∂√üe von 50 Mb direkt auf Lambda hochladen k√∂nnen, m√ºssen wir die Datei zun√§chst auf AWS S3 hochladen.&lt;/li>
&lt;li>Erstellen Sie einen Bucket und legen Sie die heruntergeladene Zip-Datei in diesen Eimer. Der Zugang kann privat bleiben und muss NICHT √∂ffentlich sein! Kopieren Sie die URL in Ihre Datei (z.B. &lt;a href="https://BUCKETNAME.s3.REGION.amazonaws.com/python.zip" title="https://BUCKETNAME.s3.REGION.amazonaws.com/python.zip">https://BUCKETNAME.s3.REGION.amazonaws.com/python.zip&lt;/a>)&lt;/li>
&lt;li>Loggen Sie sich in AWS ein und gehen Sie zu Lambda -&amp;gt; Layers (&lt;a href="https://eu-central-1.console.aws.amazon.com/lambda/home?region=eu-central-1#/layers">EU central Link&lt;/a>)&lt;/li>
&lt;li>Klicken Sie auf &amp;ldquo;Layer erstellen&amp;rdquo;, geben Sie ihr einen passenden Namen und w√§hlen Sie &amp;ldquo;Eine Datei von Amazon S3 hochladen&amp;rdquo;, und kopieren Sie den Code von Schritt 3 hinein. W√§hlen Sie als Runtimes Python 3.7. Klicken Sie auf &amp;ldquo;Erstellen&amp;rdquo;.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Kompilieren Sie Ihre eigenes Lambda-Layer&lt;/strong>&lt;/p>
&lt;p>Bitte folgen Sie den &lt;a href="https://medium.com/@marc.a.metz/docker-run-rm-it-v-pwd-var-task-lambci-lambda-build-python3-7-bash-c7d53f3b7eb2">Anweisungen von Marc&lt;/a>.&lt;/p>
&lt;h2 id="2-erstellen-einer-lambda-funktion">2. Erstellen einer Lambda Funktion&lt;/h2>
&lt;ol>
&lt;li>√ñffnen Sie das Dashboard der Lambda-Funktion (&lt;a href="https://eu-central-1.console.aws.amazon.com/lambda/home?region=eu-central-1#/functions">EU central Link&lt;/a>) und klicken Sie auf &amp;ldquo;Funktion erstellen&amp;rdquo;.&lt;/li>
&lt;li>Lassen Sie das Kontrollk√§stchen &amp;ldquo;Von Grund auf neu&amp;rdquo; unver√§ndert und geben Sie ihm einen passenden Namen.&lt;/li>
&lt;li>W√§hlen Sie in &amp;ldquo;Runtime&amp;rdquo; Python 3.7, lassen Sie den Rest unver√§ndert und klicken Sie auf &amp;ldquo;Funktion erstellen&amp;rdquo;.&lt;/li>
&lt;li>In der √úbersicht der Registerkarte &amp;ldquo;Designer&amp;rdquo; sehen Sie eine grafische Darstellung Ihrer Lambda-Funktion. Klicken Sie auf das Feld &amp;ldquo;Schichten&amp;rdquo; darunter und klicken Sie auf &amp;ldquo;Eine Schicht hinzuf√ºgen&amp;rdquo;. Wenn Sie den Layer korrekt eingerichtet haben, k√∂nnen Sie ihn im folgenden Dialog ausw√§hlen. Klicken Sie schliesslich auf &amp;ldquo;Hinzuf√ºgen&amp;rdquo;.&lt;/li>
&lt;li>In der Registerkarte &amp;ldquo;Designer&amp;rdquo; w√§hlen Sie Ihre Lambda-Funktion aus. Wenn Sie nach unten scrollen, sehen Sie ein Standard-Python-Code-Snippet in einer Datei namens &amp;ldquo;lambda_function.py&amp;rdquo;. Wenn Sie Ihren Code genauso strukturiert haben wie meinen (&lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda/blob/master/lambda_function.py">Link&lt;/a>), k√∂nnen Sie Ihre Funktion mit der run()-Funktion ausf√ºhren. Wenn eine Lambda-Funktion aufgerufen wird, wird sie die lambda_handler(event, context)-Funktion ausf√ºhren, von der aus Sie z.B. die run()-Funktion aufrufen k√∂nnen. Nat√ºrlich k√∂nnen Sie alle Dateien und Funktionen umbenennen, aber der Einfachheit halber habe ich dieses Projekt so belassen, wie es ist.&lt;/li>
&lt;li>F√ºhlen Sie sich frei, &lt;a href="https://github.com/JustinGuese/How-To-Deploy-Facebook-Prophet-on-AWS-Lambda/blob/master/lambda_function.py">meine Funktion&lt;/a> einfach einzuf√ºgen und zu testen.&lt;/li>
&lt;li>Ein Klick auf &amp;ldquo;Test&amp;rdquo; sollte zu einer erfolgreichen Ausf√ºhrung f√ºhren, andernfalls werden die Fehler im Dialog angezeigt.&lt;/li>
&lt;/ol>
&lt;h2 id="3-umgebungsvariabeln-in-aws-lambda-hinzuf√ºgen-und-nutzen">3. Umgebungsvariabeln in AWS Lambda hinzuf√ºgen und nutzen&lt;/h2>
&lt;p>Sie sollten Ihren Benutzer und Ihr Passwort niemals als Klartext in Ihrem Code hinterlassen, weshalb Sie immer Umgebungsvariablen verwenden sollten! Gl√ºcklicherweise verwendet auch Lambda diese, und sie k√∂nnen leicht mit dem Python-OS-Paket aufgerufen werden. In meinem Skript rufe ich z.B. die Benutzervariable mit os.environ[&amp;lsquo;ALPACAUSER&amp;rsquo;] auf. Die Umgebungsvariablen k√∂nnen im Hauptfunktionsbildschirm von Lambda eingerichtet werden, wenn Sie unter Ihrem Code-Editor nach unten scrollen.&lt;/p>
&lt;h2 id="4-aws-lambda-funktionen-in-einem-bestimmten-zeitintervall-ausl√∂sen">4. AWS Lambda Funktionen in einem bestimmten Zeitintervall ausl√∂sen&lt;/h2>
&lt;p>Das Konzept von Serverless und AWS Lambda basiert auf der Idee, dass eine Funktion ausgef√ºhrt wird, wenn ein Trigger-Ereignis eintritt. In meinem Setup wollte ich, dass die Funktion z.B. alle 15 Minuten w√§hrend der Handelszeiten, Montag bis Freitag, aufgerufen wird. Gl√ºcklicherweise bietet AWS eine M√∂glichkeit, ein Ereignis auszul√∂sen, ohne dass ein Server laufen muss, indem der CloudWatch-Dienst genutzt wird.&lt;/p>
&lt;ol>
&lt;li>Gehen Sie zu CloudWatch (&lt;a href="https://eu-central-1.console.aws.amazon.com/cloudwatch/home?region=eu-central-1">EU central Link&lt;/a>).&lt;/li>
&lt;li>W√§hlen Sie in der linken Leiste &amp;ldquo;Events&amp;rdquo; und &amp;ldquo;Rule&amp;rdquo;.&lt;/li>
&lt;li>Klicken Sie auf &amp;ldquo;Create Rule&amp;rdquo;, und w√§hlen Sie &amp;ldquo;Schedule&amp;rdquo; anstelle von &amp;ldquo;Event pattern&amp;rdquo;. Hier k√∂nnen Sie den einfachen &amp;ldquo;Fixed-rate&amp;rdquo;-Dialog verwenden oder einen Cron-Ausdruck erstellen. Ich benutze &lt;a href="https://crontab.guru/" title="https://crontab.guru/">https://crontab.guru/&lt;/a> (kostenlos), um Cron-Ausdr√ºcke zu erstellen. Mein Cron-Ausdruck f√ºr den oben erw√§hnten Anwendungsfall lautet &amp;ldquo;0/15 13-21 ? * MON-FRI *&amp;rdquo;.&lt;/li>
&lt;li>W√§hlen Sie in der rechten Tafel &amp;ldquo;Add Target&amp;rdquo; und w√§hlen Sie Ihre Lambda-Funktion. Sie wird automatisch zu Lambda hinzugef√ºgt.&lt;/li>
&lt;li>Klicken Sie schlie√ülich auf &amp;ldquo;Details konfigurieren&amp;rdquo;, geben Sie ihr einen Namen und klicken Sie auf &amp;ldquo;Regel erstellen&amp;rdquo;.&lt;/li>
&lt;/ol>
&lt;h2 id="5-optional-log-analysen-errorsuche">5. (optional) Log Analysen, Errorsuche&lt;/h2>
&lt;p>Wenn Sie es bis zu diesem Teil geschafft haben, sollten Sie fertig sein! Wenn Sie aber √ºberpr√ºfen wollen, ob alles funktioniert hat, k√∂nnen Sie mit CloudWatch einen Blick auf die Ausgaben der Lambda-Funktionen werfen. Gehen Sie zu CloudWatch -&amp;gt; Logs -&amp;gt; Log-Gruppen (&lt;a href="https://eu-central-1.console.aws.amazon.com/cloudwatch/home?region=eu-central-1#logsV2:log-groups">EU central Link&lt;/a>) und w√§hlen Sie Ihre Lambda-Funktion aus. In dieser √úbersicht sollten Sie die Ausgaben Ihrer Funktionen sehen k√∂nnen.&lt;/p>
&lt;p>Wenn Ihnen dieser Beitrag gefallen hat, hinterlassen Sie einen Kommentar oder schauen Sie sich andere Beitr√§ge an, um mich weiterhin zum Schreiben zu motivieren üòä.&lt;/p></description></item><item><title>Anreichern von Aktiendaten f√ºr Ihr algorithmisches Python-Handelsmodell</title><link>https://datafortress.cloud/de/blog/anreichern-von-aktiendaten-fur-ihr-algorithmisches-python-handelsmodell/</link><pubDate>Wed, 26 Jan 2022 23:00:00 +0000</pubDate><author>Justin Guese</author><guid>https://datafortress.cloud/de/blog/anreichern-von-aktiendaten-fur-ihr-algorithmisches-python-handelsmodell/</guid><description>
&lt;h1 id="ihre-ersten-schritte-beim-aufbau-eines-handelsalgorithmus">Ihre ersten Schritte beim Aufbau eines Handelsalgorithmus&lt;/h1>
&lt;p>Nehmen wir an, Sie planen, Ihr eigenes algorithmisches Handelsmodell zu erstellen.&lt;/p>
&lt;p>Sie werden h√∂chstwahrscheinlich nur Preisdaten (Close) f√ºr Ihr Modell und Ihren Algorithmus verwenden, aber bald werden Sie feststellen, dass Ihr Modell nicht gut performt.&lt;/p>
&lt;p>Bald werden Sie typische OHLCV-Daten verwenden, die sich auf Open, High, Low, Close, Volume beziehen, was schon besser ist, aber das Modell scheint nicht gut genug zu funktionieren.&lt;/p>
&lt;p>Was k√∂nnen Sie tun?&lt;/p>
&lt;p>Ein praktisches Colab-Notebook zum Mitverfolgen:&lt;/p>
&lt;p>&lt;a href="https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing" title="https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing">https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing&lt;/a>&lt;/p>
&lt;p>Gist:&lt;/p>
&lt;p>&lt;a href="https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing" title="https://colab.research.google.com/drive/1ywqti1TuTDY_Z11ry0x4ITclCwxnXAeI?usp=sharing">https://gist.github.com/JustinGuese/019e0e71100abe6555f78c32fd0b10a9&lt;/a>&lt;/p>
&lt;h1 id="wie-mag-ein-machine-learning-trading-bot">Wie mag ein Machine Learning Trading Bot?&lt;/h1>
&lt;p>Der typische maschinelle Lernalgorithmus kann nur mit den Daten arbeiten, die er erhalten hat. Er kann (in der Regel) keine neuen Merkmale oder Interpretationen wie &amp;ldquo;Wenn das Volumen steigt und die 3. Ableitung des Preises steigt, wird der Preis h√∂chstwahrscheinlich steigen&amp;rdquo; erstellen, sondern kann stattdessen nur auf die Daten &amp;ldquo;schauen&amp;rdquo;, die er erhalten hat. Das w√§ren dann Berechnungen wie &amp;ldquo;wenn der Preis √ºber 100 USD liegt und das Volumen √ºber 2000, wird der Preis h√∂chstwahrscheinlich steigen&amp;rdquo;.&lt;/p>
&lt;p>Neulinge im Bereich des maschinellen Lernens versuchen nun, dieses Problem zu l√∂sen, indem sie jahrzehntelang trainieren oder immer mehr GPUs einsetzen, aber ein weitaus effizienterer Weg w√§re es, den Algorithmus mit zus√§tzlichen Daten zu f√ºttern, so dass er mehr Ressourcen f√ºr seine Berechnungen nutzen kann.&lt;/p>
&lt;p>Dies kann erreicht werden durch:&lt;/p>
&lt;ol>
&lt;li>Mehr Daten erhalten (eine gr√∂√üere Zeitspanne)&lt;/li>
&lt;li>Hinzuf√ºgen von statistischen Metriken&lt;/li>
&lt;li>Hinzuf√ºgen Ihrer eigenen Signale und Interpretationen&lt;/li>
&lt;/ol>
&lt;h1 id="hands-on-anreicherung-ihrer-daten">Hands-on: Anreicherung Ihrer Daten&lt;/h1>
&lt;h2 id="erste-schritte---beschaffung-ihrer-daten">Erste Schritte - Beschaffung Ihrer Daten&lt;/h2>
&lt;p>Lassen Sie uns zun√§chst einige grundlegende OHLCV-Daten erfassen. Ich mag das yfinance (&lt;a href="https://pypi.org/project/yfinance/" title="https://pypi.org/project/yfinance/">https://pypi.org/project/yfinance/&lt;/a>) Modul wegen seiner Einfachheit. Es ist nicht vergleichbar mit Live-Streams von Daten, aber auf der anderen Seite ist es kostenlos und gro√üartig zum Experimentieren!&lt;/p>
&lt;pre>&lt;code>pip install yfinance pandas numpy matplotlib ta
import yfinance as yf
import matplotlib.pyplot as plt
import pandas as pd
&lt;/code>&lt;/pre>
&lt;p>Holen Sie sich einige Bestandsdaten, Intervall und Periode beziehen sich auf die Timerbereiche.&lt;/p>
&lt;p>interval akzeptiert Werte wie 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo&lt;/p>
&lt;p>Periode akzeptiert Werte wie 1d,5d,1mo,3mo,6mo,1y,2y,5y,10y,ytd,max&lt;/p>
&lt;p>Nicht alle Kombinationen funktionieren, z.B. 1m (1 Minute) Intervalle funktionieren nur mit 7d max, 1h (1 Stunde) mit 3 Monaten max (muss als 90d geschrieben werden). Aber lassen Sie uns zuerst mit t√§glichen Daten arbeiten&lt;/p>
&lt;pre>&lt;code>df = yf.download(&amp;quot;MSFT&amp;quot;,period=&amp;quot;5y&amp;quot;,interval=&amp;quot;1d&amp;quot;)
df.head()
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://datafortress.cloud/images/screenshot-from-2021-01-27-14-46-45.png" alt="">&lt;/p>
&lt;p>Kurzer Exkurs: Was zum Geier ist Open, High, Low, Close, Adj Close und Volume? Wo ist der Preis?!&lt;/p>
&lt;p>Es gibt keinen &amp;ldquo;einen Preis&amp;rdquo; an der B√∂rse! Sie k√∂nnen sich die OHLCV-Daten als &amp;ldquo;Buckets&amp;rdquo; oder &amp;ldquo;Bins&amp;rdquo; in der Zeit vorstellen, die alle Trades zusammenfassen, die in diesem Fenster stattgefunden haben. Das typische &amp;ldquo;Linien&amp;rdquo;-Diagramm, das Sie kennen, bezieht sich normalerweise auf den &amp;ldquo;Close&amp;rdquo;-Kurs dieser Aktie im Zeitbereich X, d.h. den Wert, den die Aktie am Ende des Zeitbereichs hatte.&lt;/p>
&lt;p>Wenn wir uns Tagesdaten ansehen, bezieht sich &amp;ldquo;Open&amp;rdquo; auf den durchschnittlichen (!) Aktienkurs bei Markter√∂ffnung, w√§hrend &amp;ldquo;Close&amp;rdquo; sich auf den durchschnittlichen (!) Kurs bezieht, den die Aktie bei Marktschluss hatte. Bei st√ºndlichen Daten bezieht sich &amp;ldquo;Open&amp;rdquo; auf den Beginn der jeweiligen Stunde, z. B. 11 Uhr, und &amp;ldquo;Close&amp;rdquo; auf den Schluss der Stunde, also 11:59:59 Uhr.&lt;/p>
&lt;p>Ebenso ist &amp;ldquo;High&amp;rdquo; der h√∂chste Handel/Kurs, der in diesem Zeitrahmen aufgezeichnet wurde, und &amp;ldquo;Low&amp;rdquo; der niedrigste. Das Volumen bezieht sich auf die Anzahl der Assets oder Aktien, die in diesem Zeitbereich gehandelt wurden.&lt;/p>
&lt;p>Das hei√üt, wenn z.B. &amp;ldquo;Low&amp;rdquo; und &amp;ldquo;Close&amp;rdquo; einer Spalte nahe beieinander liegen, sehen wir h√∂chstwahrscheinlich einen Abw√§rtstrend, da der Close das aktuelle Low ist. Auch wenn das Volumen hoch ist, gibt es viele Trades, wenn also z.B. das Volumen h√∂her ist als √ºblich, scheint etwas im Markt zu passieren. Aber wie auch immer, gehen Sie dazu auf &lt;a href="https://www.investopedia.com/," title="https://www.investopedia.com/,">https://www.investopedia.com/,&lt;/a> wir werden jetzt mit der Codierung fortfahren!&lt;/p>
&lt;h3 id="was-ist-adj-close">Was ist &amp;ldquo;Adj Close&amp;rdquo;?&lt;/h3>
&lt;p>Dies ist wichtig, da die meisten ML-Algorithmen durch &amp;ldquo;normale&amp;rdquo; Schlussdaten furchtbar verwirrt sind. Wenn es eine Aufspaltung der Aktie gibt, sehen die Daten so aus, als ob der Preis einen irrsinnigen R√ºckgang hat.&lt;/p>
&lt;p>Der Grund ist, einfach gesagt, dass wenn eine Aktie zu teuer wird, das Unternehmen beschlie√üt, die Aktie in zwei Teile zu &amp;ldquo;teilen&amp;rdquo;. Bedeutet das, dass sich meine Investition halbiert? Nat√ºrlich nicht, Sie erhalten einfach die doppelte Menge an Aktien, die Sie halten, so dass Sie auf dem Papier immer noch den gleichen Wert der Aktie halten.&lt;/p>
&lt;p>Interessanterweise f√ºhrt ein Split in der Regel zu steigenden Kursen (dumme Menschen!), und wenn Ihr maschineller Lernalgorithmus einen enormen Kursverfall sieht, wird er h√∂chstwahrscheinlich die Aktie auf Teufel komm raus verkaufen.&lt;/p>
&lt;p>Aus diesem Grund sollten Sie immer &amp;ldquo;bereinigte&amp;rdquo; Werte verwenden, die man sich als &amp;ldquo;bereinigte&amp;rdquo; Kursdaten vorstellen kann, bei denen Splits, Dividenden und alle anderen Ereignisse, die den wahren Wert der Daten nicht beeinflussen, ber√ºcksichtigt werden. Versuchen Sie daher, f√ºr Ihre Algorithmen immer bereinigte Daten zu verwenden!&lt;/p>
&lt;p>Im Fall von yfinance ist dies einfach zu bewerkstelligen, da wir einfach &amp;ldquo;Adj Close&amp;rdquo; anstelle von &amp;ldquo;Close&amp;rdquo; verwenden k√∂nnen.&lt;/p>
&lt;h3 id="plotten-der-daten">Plotten der Daten&lt;/h3>
&lt;p>Wenn wir uns die Daten ansehen, k√∂nnen wir bereits eine sch√∂ne, bekannte Kurve erkennen&lt;/p>
&lt;pre>&lt;code>plt.plot(df[&amp;quot;Adj Close&amp;quot;])
&lt;/code>&lt;/pre>
&lt;h2 id="schritt-2-anreichern-ihrer-daten-mit-statistischen-daten">Schritt 2: Anreichern Ihrer Daten mit statistischen Daten&lt;/h2>
&lt;p>Wie bereits erw√§hnt, m√ºssen wir weitere Informationen aus unseren Daten erzeugen, damit der Algorithmus sie verwenden kann, da er dies nicht alleine tun kann.&lt;/p>
&lt;p>Ich verwende gerne die Bibliothek ta (&lt;a href="https://github.com/bukosabino/ta" title="https://github.com/bukosabino/ta">https://github.com/bukosabino/ta&lt;/a>), da sie wiederum super einfach zu bedienen ist und √ºber 100 statistische Berechnungen enth√§lt.&lt;/p>
&lt;p>Installieren und importieren Sie sie mit&lt;/p>
&lt;pre>&lt;code>pip install ta
from ta import add_all_ta_features
from ta.utils import dropna
&lt;/code>&lt;/pre>
&lt;p>Wenn Sie nun schon wissen, welche Werte Sie verwenden wollen, k√∂nnen Sie nur diese ausw√§hlen, ooooder wir schlagen einfach alle 100+ auf unsere Daten ein:&lt;/p>
&lt;pre>&lt;code>df = dropna(df) # clean nans if present
df = add_all_ta_features(df,open=&amp;quot;Open&amp;quot;, high=&amp;quot;High&amp;quot;, low=&amp;quot;Low&amp;quot;, close=&amp;quot;Adj Close&amp;quot;, volume=&amp;quot;Volume&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>Was haben wir also getan?&lt;/p>
&lt;pre>&lt;code>df.columns
Index(['Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume', 'volume_adi',
'volume_obv', 'volume_cmf', 'volume_fi', 'volume_mfi', 'volume_em',
'volume_sma_em', 'volume_vpt', 'volume_nvi', 'volume_vwap',
'volatility_atr', 'volatility_bbm', 'volatility_bbh', 'volatility_bbl',
'volatility_bbw', 'volatility_bbp', 'volatility_bbhi',
'volatility_bbli', 'volatility_kcc', 'volatility_kch', 'volatility_kcl',
'volatility_kcw', 'volatility_kcp', 'volatility_kchi',
'volatility_kcli', 'volatility_dcl', 'volatility_dch', 'volatility_dcm',
'volatility_dcw', 'volatility_dcp', 'volatility_ui', 'trend_macd',
'trend_macd_signal', 'trend_macd_diff', 'trend_sma_fast',
'trend_sma_slow', 'trend_ema_fast', 'trend_ema_slow', 'trend_adx',
'trend_adx_pos', 'trend_adx_neg', 'trend_vortex_ind_pos',
'trend_vortex_ind_neg', 'trend_vortex_ind_diff', 'trend_trix',
'trend_mass_index', 'trend_cci', 'trend_dpo', 'trend_kst',
'trend_kst_sig', 'trend_kst_diff', 'trend_ichimoku_conv',
'trend_ichimoku_base', 'trend_ichimoku_a', 'trend_ichimoku_b',
'trend_visual_ichimoku_a', 'trend_visual_ichimoku_b', 'trend_aroon_up',
'trend_aroon_down', 'trend_aroon_ind', 'trend_psar_up',
'trend_psar_down', 'trend_psar_up_indicator',
'trend_psar_down_indicator', 'trend_stc', 'momentum_rsi',
'momentum_stoch_rsi', 'momentum_stoch_rsi_k', 'momentum_stoch_rsi_d',
'momentum_tsi', 'momentum_uo', 'momentum_stoch',
'momentum_stoch_signal', 'momentum_wr', 'momentum_ao', 'momentum_kama',
'momentum_roc', 'momentum_ppo', 'momentum_ppo_signal',
'momentum_ppo_hist', 'others_dr', 'others_dlr', 'others_cr'],
dtype='object')
&lt;/code>&lt;/pre>
&lt;p>Nun, das sollte f√ºr den Moment reichen!&lt;/p>
&lt;p>Au√üerdem ist immer noch eine Menge Nans drin, da einige Werte nur berechnet werden, wenn genug Zeit vergangen ist. Meiner Erfahrung nach funktioniert das Auff√ºllen mit Nullen ganz gut, auch wenn es daf√ºr fortgeschrittenere Techniken gibt.&lt;/p>
&lt;pre>&lt;code>df = df.fillna(0)
&lt;/code>&lt;/pre>
&lt;h2 id="schritt-3-erstellen-sie-ihre-eigenen-signale">Schritt 3: Erstellen Sie Ihre eigenen Signale&lt;/h2>
&lt;p>Jetzt ist es an der Zeit, Ihre verr√ºckten Handelsideen in Zahlen zu √ºbersetzen!&lt;/p>
&lt;p>Beginnen wir mit dem klassischen Moving Average Cross. Die Idee ist wie folgt: Wenn ein kurzer gleitender Durchschnitt einen langsameren gleitenden Durchschnitt kreuzt, deutet dies entweder auf einen Kursanstieg oder einen Kursr√ºckgang hin, je nach Richtung des Kreuzes.&lt;/p>
&lt;p>Auch hier k√∂nnen Sie bei investopedia Details nachlesen: &lt;a href="https://www.investopedia.com/articles/active-trading/052014/how-use-moving-average-buy-stocks.asp" title="https://www.investopedia.com/articles/active-trading/052014/how-use-moving-average-buy-stocks.asp">https://www.investopedia.com/articles/active-trading/052014/how-use-moving-average-buy-stocks.asp&lt;/a>&lt;/p>
&lt;p>Unser Ziel ist es, zun√§chst die SMAs zu berechnen und dann die Kreuzungen als 1 und -1 zu formulieren, und 0, um keine Kreuzung zu signalisieren.&lt;/p>
&lt;h3 id="erstellen-einfacher-gleitender-durchschnitte">Erstellen einfacher gleitender Durchschnitte&lt;/h3>
&lt;pre>&lt;code># creating simple moving averages
averages = [1,2,5,10,15,20,25,50,100]
for average in averages:
df['SMA_%d'%average] = df[&amp;quot;Adj Close&amp;quot;].rolling(window=average).mean()
# visualize only SMAs
filter_col = [col for col in df if col.startswith('SMA')]
df[filter_col].tail()
&lt;/code>&lt;/pre>
&lt;p>Und Visualisierung:&lt;/p>
&lt;pre>&lt;code># results in bigger figures
plt.rcParams[&amp;quot;figure.figsize&amp;quot;] = (20,20)
for filter in filter_col:
plt.plot(df[filter],label=filter)
plt.legend()
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://datafortress.cloud/images/download.png" alt="">&lt;/p>
&lt;h3 id="erzeugen-eines-crossover-signals">Erzeugen eines Crossover-Signals&lt;/h3>
&lt;p>Lassen Sie uns eine kleine Hilfsfunktion verwenden&lt;/p>
&lt;pre>&lt;code>def createCross(data,fastSMA,slowSMA):
fast = 'SMA_%d'%fastSMA
slow = 'SMA_%d'%slowSMA
crossname = &amp;quot;cross_%d_%d&amp;quot;%(fastSMA,slowSMA)
previous_fast = data[fast].shift(1)
previous_slow = data[slow].shift(1)
neg = ((data[fast] &amp;lt; data[slow]) &amp;amp; (previous_fast &amp;gt;= previous_slow))
pos = ((data[fast] &amp;gt; data[slow]) &amp;amp; (previous_fast &amp;lt;= previous_slow))
data[crossname] = 0
data.loc[neg,crossname] = -1
data.loc[pos,crossname] = 1
return data
&lt;/code>&lt;/pre>
&lt;p>Und nun k√∂nnen Sie entweder eigene Werte einf√ºgen oder unserem Beispiel folgen und einfach die Querprodukte nehmen:&lt;/p>
&lt;pre>&lt;code>for fast in averages:
for slow in averages:
if fast != slow and slow &amp;gt; fast:
df = createCross(df,fast,slow)
&lt;/code>&lt;/pre>
&lt;p>Dadurch wurde ein perfektes Klassifizierungssignal erzeugt, das ein Aufw√§rtskreuz mit 1 und ein Abw√§rtskreuz mit -1 signalisiert, wobei 0 ein neutraler Wert (kein Kreuz) ist.&lt;/p>
&lt;p>Dies ist nur ein Beispiel daf√ºr, welche weiteren Signale Sie geben k√∂nnen.&lt;/p>
&lt;h3 id="erstellen-einer-spalte-f√ºr-die-prozentuale-ver√§nderung">Erstellen einer Spalte f√ºr die prozentuale Ver√§nderung&lt;/h3>
&lt;p>Um ein weiteres Beispiel hinzuzuf√ºgen: Wenn Sie versuchen, die prozentuale Ver√§nderung vorherzusagen, ben√∂tigen Sie eine Spalte, die die prozentuale Ver√§nderung zum vorherigen Zeitbereich anzeigt. Dies l√§sst sich gl√ºcklicherweise leicht mit Pandas erledigen.&lt;/p>
&lt;pre>&lt;code>df[&amp;quot;pct_change&amp;quot;] = df[&amp;quot;Adj Close&amp;quot;].pct_change()
Date
2021-01-21 0.013363
2021-01-22 -0.004463
2021-01-25 0.000538
2021-01-26 0.009754
2021-01-27 -0.010484
Name: pct_change, dtype: float64
&lt;/code>&lt;/pre>
&lt;p>Was f√ºr ein perfektes Signal f√ºr ein regressives Modell!&lt;/p>
&lt;h1 id="zusammenfassung">Zusammenfassung&lt;/h1>
&lt;p>Bevor wir unsere Erweiterungen hinzugef√ºgt haben, enthielt der Datenrahmen nur 5 Spalten, nicht viel f√ºr ein maschinelles Lernmodell!&lt;/p>
&lt;p>Am Ende, nach dem Hinzuf√ºgen von statistischen Werten und unseren eigenen Signalen, haben wir bereits 135 Features und Spalten unseres Datenrahmens erreicht!&lt;/p>
&lt;p>So viel besser f√ºr Ihr Modell!&lt;/p>
&lt;p>Was sind Ihre Gedanken zu diesem Prozess? Habe ich etwas √ºbersehen? M√∂chten Sie mehr Artikel von Justin lesen? Schauen Sie auf meiner Website vorbei und lesen Sie mehr!&lt;/p></description></item></channel></rss>